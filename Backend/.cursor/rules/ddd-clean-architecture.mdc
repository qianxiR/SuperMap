# DDD + 清洁架构开发规范

## 架构层次关系

本项目采用四层清洁架构设计：
- **API层** (Controller) → **应用层** (Use Case) → **领域层** (Domain) → **基础设施层** (Infrastructure)

## 各层职责与编码规范

### 🟦 领域层 (Domain layer) - 业务核心

**原则**: 不依赖任何外部技术，只包含业务逻辑

#### 实体 (Entities)
- 位置: `analysis/domains/{domain}/entities.py`
- 职责: 定义业务核心概念和业务规则
- 规范:
  - 使用 `@dataclass` 装饰器
  - 包含业务验证逻辑
  - 提供工厂方法 `create_new()`
  - 不依赖外部框架

#### 值对象 (Value Objects)
- 位置: `analysis/domains/{domain}/value_objects.py`
- 职责: 封装不可变的值和验证规则
- 规范:
  - 使用 `@dataclass(frozen=True)`
  - 在 `__post_init__` 中进行验证
  - 提供 `create()` 类方法

#### 仓储接口 (Repository Interface)
- 位置: `analysis/domains/{domain}/repositories.py`
- 职责: 定义数据操作契约
- 规范:
  - 使用抽象基类 `ABC`
  - 定义异步方法
  - 不包含具体实现

#### 领域服务 (Domain Services)
- 位置: `analysis/domains/{domain}/services.py`
- 职责: 复杂业务逻辑协调
- 规范:
  - 依赖仓储接口
  - 包含业务规则验证
  - 不处理HTTP或数据库细节

### 🟢 应用层 (Application layer) - 业务流程编排

**原则**: 协调领域层组件，不包含业务规则

#### 用例 (Use Cases)
- 位置: `analysis/application/use_cases/{domain}/`
- 职责: 业务流程编排
- 规范:
  - 依赖领域服务
  - 处理DTO转换
  - 不包含业务规则
  - 返回统一格式结果

#### DTO (Data Transfer Objects)
- 位置: `analysis/application/dto/`
- 职责: 数据传输和验证
- 规范:
  - 使用 Pydantic BaseModel
  - 包含输入验证
  - 隔离外部请求与领域实体

### 🟡 API层 (API layer) - 对外接口

**原则**: 处理HTTP请求/响应，参数验证，错误处理

#### 路由 (Routes)
- 位置: `analysis/api/v1/{domain}/`
- 职责: HTTP接口定义
- 规范:
  - 使用 FastAPI 路由
  - 依赖注入用例
  - 统一错误处理
  - 参数验证

### 🟠 基础设施层 (Infrastructure layer) - 技术实现

**原则**: 实现具体技术细节，为内层提供支撑

#### 仓储实现 (Repository Implementation)
- 位置: `analysis/infrastructure/database/{database}/repositories.py`
- 职责: 具体数据访问实现
- 规范:
  - 实现领域层仓储接口
  - 处理数据库连接
  - 实体与模型转换

#### 外部服务集成
- 位置: `analysis/infrastructure/external/{service}/`
- 职责: 第三方服务封装
- 规范:
  - 封装外部API调用
  - 错误处理和重试
  - 配置管理

## 代码编写最佳实践

### 1. 依赖倒置原则
- 内层不依赖外层
- 外层依赖内层接口
- 使用依赖注入容器

### 2. 单一职责原则
- 每个类只负责一个职责
- 方法功能单一明确
- 避免上帝类

### 3. 开闭原则
- 对扩展开放
- 对修改关闭
- 使用策略模式

### 4. 接口隔离原则
- 客户端不依赖不需要的接口
- 接口功能单一
- 避免胖接口

## 文件命名规范

- 实体: `entities.py`
- 值对象: `value_objects.py`
- 仓储: `repositories.py`
- 服务: `services.py`
- 用例: `{domain}_use_case.py`
- DTO: `{domain}_dto.py`
- API: `{domain}.py`

## 开发流程

1. **从领域层开始**: 定义实体、值对象、仓储接口
2. **实现应用层**: 定义DTO、实现用例
3. **开发基础设施层**: 实现仓储、集成外部服务
4. **暴露API接口**: 定义路由、处理请求响应

## 测试策略

- **领域层**: 单元测试业务逻辑
- **应用层**: 集成测试用例
- **基础设施层**: 集成测试数据访问
- **API层**: 端到端测试接口

## 实际代码实现参考

### 领域实体示例
```python
# analysis/domains/analysis/entities.py
@dataclass
class AnalysisTask:
    """分析任务实体"""
    id: UUID
    name: str
    description: Optional[str]
    analysis_type: AnalysisType
    parameters: Dict[str, Any]
    status: AnalysisStatus
    created_by: str
    created_at: datetime
    updated_at: datetime
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    progress: float = 0.0
    supermap_request: Optional[SuperMapRequest] = None
    supermap_result: Optional[SuperMapResult] = None
    error_message: Optional[str] = None
    
    @classmethod
    def create_new(
        cls,
        name: str,
        analysis_type: AnalysisType,
        parameters: Dict[str, Any],
        created_by: str,
        description: Optional[str] = None
    ) -> "AnalysisTask":
        """创建新的分析任务"""
        return cls(
            id=uuid4(),
            name=name,
            description=description,
            analysis_type=analysis_type,
            parameters=parameters,
            status=AnalysisStatus.PENDING,
            created_by=created_by,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
```

### 领域服务示例
```python
# analysis/domains/analysis/services.py
class AnalysisService:
    """分析服务"""
    
    def __init__(
        self,
        task_repository: AnalysisTaskRepository,
        result_repository: AnalysisResultRepository,
        spatial_data_repository: SpatialDataRepository
    ):
        self.task_repository = task_repository
        self.result_repository = result_repository
        self.spatial_data_repository = spatial_data_repository
    
    async def create_analysis_task(
        self,
        name: str,
        analysis_type: AnalysisType,
        parameters: Dict[str, Any],
        created_by: str,
        description: Optional[str] = None
    ) -> AnalysisTask:
        """创建分析任务"""
        task = AnalysisTask.create_new(
            name=name,
            analysis_type=analysis_type,
            parameters=parameters,
            created_by=created_by,
            description=description
        )
        return await self.task_repository.create(task)
```

### 应用用例示例
```python
# analysis/application/use_cases/analysis/analysis_use_case.py
class AnalysisUseCase:
    """分析用例"""
    
    def __init__(self, analysis_service: AnalysisService):
        self.analysis_service = analysis_service
    
    async def create_analysis_task(
        self,
        task_data: AnalysisTaskCreateDTO,
        created_by: str
    ) -> Dict[str, Any]:
        """创建分析任务"""
        task = await self.analysis_service.create_analysis_task(
            name=task_data.name,
            analysis_type=task_data.analysis_type,
            parameters=task_data.parameters,
            created_by=created_by,
            description=task_data.description
        )
        
        return {
            "success": True,
            "message": "分析任务创建成功",
            "data": AnalysisTaskResponseDTO(**task.to_dict())
        }
```

### API路由示例
```python
# analysis/api/v1/analysis/analysis.py
@router.post("/tasks", response_model=Dict[str, Any])
async def create_analysis_task(
    task_data: AnalysisTaskCreateDTO,
    session = Depends(get_db)
) -> Dict[str, Any]:
    """创建分析任务"""
    try:
        analysis_use_case = build_analysis_use_case(session)
        created_by = "test_user"  # 从JWT token获取
        result = await analysis_use_case.create_analysis_task(task_data, created_by)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="创建分析任务失败")
```

### 基础设施层示例
```python
# analysis/infrastructure/database/postgres/models.py
class AnalysisTaskModel(Base):
    """分析任务数据库模型"""
    __tablename__ = "analysis_tasks"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=True)
    analysis_type = Column(String(50), nullable=False, index=True)
    parameters = Column(JSONB, nullable=False)
    status = Column(String(20), nullable=False, index=True)
    created_by = Column(String(100), nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    progress = Column(Float, default=0.0, nullable=False)
    
    # SuperMap相关字段
    supermap_request = Column(JSONB, nullable=True)
    supermap_result = Column(JSONB, nullable=True)
    error_message = Column(Text, nullable=True)
```

## 依赖注入容器

```python
# analysis/core/container.py
def build_analysis_use_case(session) -> AnalysisUseCase:
    """构建分析用例"""
    # 构建仓储
    task_repository = AnalysisTaskRepository(session)
    result_repository = AnalysisResultRepository(session)
    spatial_data_repository = SpatialDataRepository(session)
    
    # 构建领域服务
    analysis_service = AnalysisService(
        task_repository=task_repository,
        result_repository=result_repository,
        spatial_data_repository=spatial_data_repository
    )
    
    # 构建用例
    return AnalysisUseCase(analysis_service=analysis_service)
```

## 开发检查清单

在实现新功能时，必须检查：
- [ ] 是否遵循分层架构原则
- [ ] 是否在正确的层次实现功能
- [ ] 是否使用依赖注入
- [ ] 是否定义清晰的接口
- [ ] 是否实现完整的错误处理
- [ ] 是否包含单元测试
- [ ] 是否遵循命名规范
- [ ] 是否包含完整的文档
