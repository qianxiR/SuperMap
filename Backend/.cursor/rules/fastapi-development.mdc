# FastAPI 开发规范与最佳实践

## 应用结构规范

### 主应用入口
```python
# main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from analysis.api.v1.analysis import router as analysis_router
from analysis.core.config import settings
from analysis.core.database import engine, Base

def create_application() -> FastAPI:
    """创建FastAPI应用"""
    app = FastAPI(
        title=settings.PROJECT_NAME,
        version=settings.VERSION,
        description=settings.DESCRIPTION,
        openapi_url=f"{settings.API_V1_STR}/openapi.json"
    )
    
    # 中间件配置
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.ALLOWED_HOSTS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # 路由注册
    app.include_router(analysis_router, prefix=settings.API_V1_STR)
    
    return app

app = create_application()
```

### 路由组织
```python
# analysis/api/v1/analysis/analysis.py
from fastapi import APIRouter, Depends, HTTPException, status, Query
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Dict, Any, Optional

from analysis.application.dto.analysis_dto import (
    AnalysisTaskCreateDTO, AnalysisTaskUpdateDTO,
    SpatialDataCreateDTO, SpatialDataUpdateDTO
)
from analysis.application.use_cases.analysis.analysis_use_case import AnalysisUseCase
from analysis.core.database import get_db
from analysis.core.container import build_analysis_use_case

router = APIRouter()
security = HTTPBearer()
```

## 依赖注入规范

### 依赖定义
```python
# analysis/core/database.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.orm import declarative_base
from analysis.core.config import settings

# 创建异步引擎
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=False
)

# 创建会话工厂
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# 基础模型类
Base = declarative_base()

async def get_db() -> AsyncSession:
    """获取数据库会话"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
```

### 用例依赖
```python
# analysis/core/container.py
def build_analysis_use_case(session) -> AnalysisUseCase:
    """构建分析用例"""
    # 构建仓储
    task_repository = AnalysisTaskRepository(session)
    result_repository = AnalysisResultRepository(session)
    spatial_data_repository = SpatialDataRepository(session)
    
    # 构建领域服务
    analysis_service = AnalysisService(
        task_repository=task_repository,
        result_repository=result_repository,
        spatial_data_repository=spatial_data_repository
    )
    
    # 构建用例
    return AnalysisUseCase(analysis_service=analysis_service)
```

## 请求响应模型规范

### Pydantic模型
```python
# analysis/application/dto/analysis_dto.py
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from analysis.domains.analysis.entities import AnalysisType, AnalysisStatus

class GeometryDTO(BaseModel):
    """几何数据DTO"""
    type: str = Field(..., description="几何类型：Point/LineString/Polygon")
    coordinates: List[Any] = Field(..., description="坐标数组")

class AnalysisTaskCreateDTO(BaseModel):
    """创建分析任务DTO"""
    name: str = Field(..., min_length=1, max_length=100, description="任务名称")
    description: Optional[str] = Field(None, max_length=500, description="任务描述")
    analysis_type: AnalysisType = Field(..., description="分析类型")
    parameters: Dict[str, Any] = Field(..., description="分析参数")

class AnalysisTaskResponseDTO(BaseModel):
    """分析任务响应DTO"""
    task_id: str
    name: str
    description: Optional[str]
    analysis_type: str
    status: str
    progress: float
    created_at: str
    started_at: Optional[str]
    completed_at: Optional[str]
    supermap_request: Optional[Dict[str, Any]]
    supermap_result: Optional[Dict[str, Any]]
    error_message: Optional[str]
```

## 路由处理规范

### 标准路由模式
```python
# analysis/api/v1/analysis/analysis.py
@router.post("/tasks", response_model=Dict[str, Any])
async def create_analysis_task(
    task_data: AnalysisTaskCreateDTO,
    session = Depends(get_db)
) -> Dict[str, Any]:
    """
    创建分析任务
    
    - **name**: 任务名称 (1-100字符)
    - **description**: 任务描述 (可选，最多500字符)
    - **analysis_type**: 分析类型
    - **parameters**: 分析参数
    """
    try:
        analysis_use_case = build_analysis_use_case(session)
        
        # TODO: 从JWT token中获取用户ID
        created_by = "test_user"  # 临时使用测试用户
        
        result = await analysis_use_case.create_analysis_task(task_data, created_by)
        return result
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="创建分析任务失败，请稍后重试"
        )

@router.get("/tasks/{task_id}", response_model=Dict[str, Any])
async def get_analysis_task(
    task_id: str,
    session = Depends(get_db)
) -> Dict[str, Any]:
    """获取分析任务"""
    try:
        analysis_use_case = build_analysis_use_case(session)
        result = await analysis_use_case.get_analysis_task(task_id)
        return result
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取分析任务失败"
        )

@router.get("/tasks", response_model=Dict[str, Any])
async def list_analysis_tasks(
    skip: int = Query(0, ge=0, description="跳过记录数"),
    limit: int = Query(100, ge=1, le=1000, description="返回记录数"),
    status: Optional[str] = Query(None, description="任务状态"),
    analysis_type: Optional[str] = Query(None, description="分析类型"),
    session = Depends(get_db)
) -> Dict[str, Any]:
    """列出分析任务"""
    try:
        analysis_use_case = build_analysis_use_case(session)
        result = await analysis_use_case.list_analysis_tasks(
            skip=skip,
            limit=limit,
            status=status,
            analysis_type=analysis_type
        )
        return result
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取任务列表失败"
        )

@router.put("/tasks/{task_id}/status", response_model=Dict[str, Any])
async def update_task_status(
    task_id: str,
    status: str,
    supermap_result: Optional[Dict[str, Any]] = None,
    error_message: Optional[str] = None,
    session = Depends(get_db)
) -> Dict[str, Any]:
    """更新任务状态"""
    try:
        analysis_use_case = build_analysis_use_case(session)
        result = await analysis_use_case.update_task_status(
            task_id=task_id,
            status=status,
            supermap_result=supermap_result,
            error_message=error_message
        )
        return result
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="更新任务状态失败"
        )
```

## 错误处理规范

### 异常处理
```python
# analysis/api/v1/analysis/analysis.py
from fastapi import HTTPException, status

# 参数验证错误
@router.post("/tasks")
async def create_analysis_task(task_data: AnalysisTaskCreateDTO):
    try:
        # 业务逻辑
        pass
    except ValueError as e:
        # 业务验证错误
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        # 系统错误
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="创建分析任务失败，请稍后重试"
        )
```

### 统一错误响应
```python
# analysis/application/dto/analysis_dto.py
class AnalysisResponseDTO(BaseModel):
    """通用分析响应DTO"""
    success: bool = Field(..., description="是否成功")
    message: str = Field(..., description="响应消息")
    data: Optional[Dict[str, Any]] = Field(None, description="响应数据")
    error_code: Optional[str] = Field(None, description="错误代码")
    details: Optional[Dict[str, Any]] = Field(None, description="错误详情")
```

## 配置管理规范

### 环境配置
```python
# analysis/core/config.py
from pydantic_settings import BaseSettings
from typing import List, Optional
from functools import lru_cache

class Settings(BaseSettings):
    """应用配置"""
    
    # 基础配置
    PROJECT_NAME: str = "SuperMap GIS 分析服务"
    VERSION: str = "1.0.0"
    DESCRIPTION: str = "基于SuperMap的空间分析服务"
    
    # API配置
    API_V1_STR: str = "/api/v1"
    
    # 数据库配置
    DATABASE_URL: str
    
    # CORS配置
    ALLOWED_HOSTS: List[str] = ["*"]
    
    # SuperMap配置
    SUPERMAP_BASE_URL: str
    SUPERMAP_API_KEY: str
    
    # 日志配置
    LOG_LEVEL: str = "INFO"
    LOG_FILE: Optional[str] = None
    
    class Config:
        env_file = ".env"
        case_sensitive = True

@lru_cache()
def get_settings() -> Settings:
    """获取配置实例"""
    return Settings()

settings = get_settings()
```

## 数据库集成规范

### 数据库连接
```python
# analysis/core/database.py
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.orm import declarative_base
from analysis.core.config import settings

# 创建异步引擎
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=False
)

# 创建会话工厂
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# 基础模型类
Base = declarative_base()

async def get_db() -> AsyncSession:
    """获取数据库会话"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
```

### 数据库模型
```python
# analysis/infrastructure/database/postgres/models.py
from sqlalchemy import Column, String, Boolean, DateTime, Text, Integer, Float, ForeignKey, JSON
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid

from analysis.core.database import Base

class AnalysisTaskModel(Base):
    """分析任务数据库模型"""
    __tablename__ = "analysis_tasks"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=True)
    analysis_type = Column(String(50), nullable=False, index=True)
    parameters = Column(JSONB, nullable=False)
    status = Column(String(20), nullable=False, index=True)
    created_by = Column(String(100), nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    progress = Column(Float, default=0.0, nullable=False)
    
    # SuperMap相关字段
    supermap_request = Column(JSONB, nullable=True)
    supermap_result = Column(JSONB, nullable=True)
    error_message = Column(Text, nullable=True)
```

## 测试规范

### API测试
```python
# tests/test_api/test_analysis.py
import pytest
from httpx import AsyncClient
from analysis.main import app

class TestAnalysisAPI:
    """分析API测试"""
    
    @pytest.mark.asyncio
    async def test_create_analysis_task_success(self):
        """测试创建分析任务成功"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post("/api/v1/analysis/tasks", json={
                "name": "测试任务",
                "description": "测试描述",
                "analysis_type": "custom",
                "parameters": {
                    "geometry": {
                        "type": "Point",
                        "coordinates": [116.4074, 39.9042]
                    }
                }
            })
            
            assert response.status_code == 200
            data = response.json()
            assert data["success"] is True
            assert data["message"] == "分析任务创建成功"
    
    @pytest.mark.asyncio
    async def test_create_analysis_task_validation_error(self):
        """测试创建分析任务验证错误"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            response = await client.post("/api/v1/analysis/tasks", json={
                "name": "",  # 空名称
                "analysis_type": "invalid_type",  # 无效类型
                "parameters": {}  # 空参数
            })
            
            assert response.status_code == 422
```

## 性能优化规范

### 异步处理
```python
# 异步路由处理
@router.post("/tasks")
async def create_analysis_task(
    task_data: AnalysisTaskCreateDTO,
    session = Depends(get_db)
) -> Dict[str, Any]:
    """创建分析任务 - 异步处理"""
    try:
        analysis_use_case = build_analysis_use_case(session)
        created_by = "test_user"
        
        # 异步执行分析
        result = await analysis_use_case.create_analysis_task(task_data, created_by)
        return result
    except Exception as e:
        logger.error(f"创建分析任务失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="创建分析任务失败，请稍后重试"
        )
```

### 分页查询
```python
@router.get("/tasks")
async def list_analysis_tasks(
    skip: int = Query(0, ge=0, description="跳过记录数"),
    limit: int = Query(100, ge=1, le=1000, description="返回记录数"),
    status: Optional[str] = Query(None, description="任务状态"),
    analysis_type: Optional[str] = Query(None, description="分析类型"),
    session = Depends(get_db)
) -> Dict[str, Any]:
    """列出分析任务 - 支持分页和过滤"""
    try:
        analysis_use_case = build_analysis_use_case(session)
        result = await analysis_use_case.list_analysis_tasks(
            skip=skip,
            limit=limit,
            status=status,
            analysis_type=analysis_type
        )
        return result
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取任务列表失败"
        )
```

## 文档规范

### OpenAPI文档
```python
# 自定义OpenAPI文档
def custom_openapi():
    """自定义OpenAPI文档"""
    if app.openapi_schema:
        return app.openapi_schema
    
    openapi_schema = get_openapi(
        title=settings.PROJECT_NAME,
        version=settings.VERSION,
        description=settings.DESCRIPTION,
        routes=app.routes,
    )
    
    # 添加安全配置
    openapi_schema["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    }
    
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi
```

### 路由文档
```python
@router.post(
    "/tasks",
    response_model=Dict[str, Any],
    summary="创建分析任务",
    description="创建新的空间分析任务",
    response_description="分析任务创建结果",
    tags=["空间分析"]
)
async def create_analysis_task(
    task_data: AnalysisTaskCreateDTO = Body(
        ...,
        example={
            "name": "缓冲区分析任务",
            "description": "对指定点进行100米缓冲区分析",
            "analysis_type": "buffer",
            "parameters": {
                "geometry": {
                    "type": "Point",
                    "coordinates": [116.4074, 39.9042]
                },
                "distance": 100,
                "unit": "meters"
            }
        }
    )
):
    """
    创建分析任务
    
    - **name**: 任务名称 (1-100字符)
    - **description**: 任务描述 (可选，最多500字符)
    - **analysis_type**: 分析类型
    - **parameters**: 分析参数，包含几何数据和具体分析设置
    
    返回创建结果，包含任务ID和状态信息。
    """
    pass
```

## 开发检查清单

在实现新的API接口时，必须检查：
- [ ] 是否使用正确的HTTP方法
- [ ] 是否定义完整的请求/响应模型
- [ ] 是否包含参数验证
- [ ] 是否实现错误处理
- [ ] 是否使用依赖注入
- [ ] 是否包含API文档
- [ ] 是否支持分页查询
- [ ] 是否实现异步处理
- [ ] 是否包含单元测试
- [ ] 是否遵循命名规范
