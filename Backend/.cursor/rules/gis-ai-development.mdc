# GIS + AI 智能分析系统开发规范

## 🏗️ 微服务架构设计

### 服务分离策略
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   API Gateway   │    │   Load Balancer │
│   (Vue.js)      │◄──►│   (FastAPI)     │◄──►│   (Nginx)       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                ┌───────────────┼───────────────┐
                │               │               │
        ┌───────▼──────┐ ┌──────▼──────┐ ┌─────▼─────┐
        │   AI Service │ │ GIS Service │ │ User Auth │
        │   (Python)   │ │(JavaScript) │ │ (Python)  │
        │  LangChain   │ │  Node.js    │ │  FastAPI  │
        └──────────────┘ └─────────────┘ └───────────┘
```

## 🔧 技术栈规范

### AI服务 (Python + LangChain)
- **语言**: Python 3.11+
- **AI框架**: LangChain + OpenAI
- **Web框架**: FastAPI + Uvicorn
- **数据库**: PostgreSQL + PostGIS (空间数据)
- **缓存**: Redis Cluster
- **向量数据库**: Qdrant/Weaviate
- **监控**: Prometheus + Grafana

### GIS分析服务 (JavaScript + Node.js)
- **语言**: JavaScript/TypeScript
- **运行时**: Node.js 18+
- **Web框架**: Express.js + Koa.js
- **GIS库**: Turf.js, JSTS
- **数据库**: PostgreSQL + PostGIS
- **缓存**: Redis
- **任务队列**: Bull/BullMQ
- **监控**: PM2 + New Relic

### 前端服务 (Vue.js)
- **框架**: Vue.js 3 + TypeScript
- **地图**: SuperMap iClient
- **状态管理**: Pinia
- **UI组件**: 自定义组件库
- **构建工具**: Vite

## 🐍 AI服务开发规范 (Python)

### 项目结构
```
ai-service/
├── app/
│   ├── domains/           # 领域层
│   │   ├── agent/        # 智能体域
│   │   ├── knowledge/    # 知识库域
│   │   └── workflow/     # 工作流域
│   ├── application/      # 应用层
│   ├── infrastructure/   # 基础设施层
│   │   ├── ai/          # AI基础设施
│   │   ├── database/    # 数据访问
│   │   └── external/    # 外部服务
│   └── api/             # API层
├── requirements.txt
├── Dockerfile
└── docker-compose.yml
```

### LangChain集成规范
```python
# infrastructure/ai/agent_hub.py
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain.tools import BaseTool
from langchain.schema import BaseMessage
from typing import List, Dict, Any

class AgentHub:
    """智能体协调中心"""
    
    def __init__(self):
        self.coordinator = CoordinatorAgent()
        self.executor = ExecutorAgent()
        self.aggregator = AggregatorAgent()
        self.tools = self._load_tools()
    
    def _load_tools(self) -> List[BaseTool]:
        """加载工具集"""
        return [
            GISAnalysisTool(),
            KnowledgeSearchTool(),
            DataQueryTool()
        ]
    
    async def process_query(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """处理用户查询"""
        # 1. 协调智能体解析意图
        intent = await self.coordinator.analyze_intent(query, context)
        
        # 2. 执行智能体并行处理
        results = await self.executor.execute_tasks(intent.tasks, self.tools)
        
        # 3. 聚合智能体整合结果
        final_result = await self.aggregator.combine_results(results)
        
        return final_result

class CoordinatorAgent:
    """协调智能体"""
    
    async def analyze_intent(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """分析用户意图"""
        prompt = f"""
        你是一个GIS分析协调智能体，负责解析用户的地理分析需求。
        
        用户查询: {query}
        上下文: {context}
        
        请分析用户意图并生成执行计划:
        1. 识别分析类型 (缓冲区、距离、可达性等)
        2. 提取关键参数 (半径、目标对象等)
        3. 生成执行任务列表
        
        返回JSON格式的执行计划。
        """
        
        # 调用OpenAI API
        response = await self.llm_client.chat_completion(prompt)
        return self._parse_intent(response.content)

class ExecutorAgent:
    """执行智能体"""
    
    async def execute_tasks(self, tasks: List[Dict], tools: List[BaseTool]) -> List[Dict]:
        """执行任务列表"""
        results = []
        
        for task in tasks:
            # 选择合适的工具
            tool = self._select_tool(task, tools)
            
            # 执行任务
            result = await tool.execute(task)
            results.append(result)
        
        return results

class AggregatorAgent:
    """聚合智能体"""
    
    async def combine_results(self, results: List[Dict]) -> Dict[str, Any]:
        """整合结果"""
        # 分析结果聚合逻辑
        combined_result = {
            "success": True,
            "data": results,
            "summary": self._generate_summary(results),
            "visualization": self._generate_visualization(results)
        }
        
        return combined_result
```

### 工具集成
```python
# infrastructure/ai/tools/gis_tools.py
from langchain.tools import BaseTool
from typing import Dict, Any
import httpx

class GISAnalysisTool(BaseTool):
    """GIS分析工具"""
    
    name = "gis_analysis"
    description = "执行GIS空间分析，包括缓冲区、距离、可达性分析"
    
    async def _run(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """执行GIS分析"""
        # 调用GIS服务API
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://gis-service:3000/api/v1/analysis",
                json=task,
                timeout=30.0
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                raise Exception(f"GIS分析失败: {response.text}")
    
    async def _arun(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """异步执行"""
        return await self._run(task)

class KnowledgeSearchTool(BaseTool):
    """知识库搜索工具"""
    
    name = "knowledge_search"
    description = "搜索GIS相关知识库"
    
    async def _run(self, query: str) -> Dict[str, Any]:
        """搜索知识库"""
        # 向量数据库搜索
        results = await self.vector_db.search(query, top_k=5)
        return {"results": results}
```

## 🟨 GIS分析服务开发规范 (JavaScript)

### 项目结构
```
gis-service/
├── src/
│   ├── domains/          # 领域层
│   │   ├── spatial/     # 空间分析域
│   │   ├── geometry/    # 几何处理域
│   │   └── data/        # 数据管理域
│   ├── application/     # 应用层
│   ├── infrastructure/  # 基础设施层
│   │   ├── database/   # 数据访问
│   │   ├── cache/      # 缓存服务
│   │   └── external/   # 外部服务
│   ├── api/            # API层
│   └── utils/          # 工具函数
├── package.json
├── Dockerfile
└── docker-compose.yml
```

### Express.js应用结构
```javascript
// src/app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const compression = require('compression');

const spatialAnalysisRoutes = require('./api/routes/spatial-analysis');
const geometryRoutes = require('./api/routes/geometry');
const dataRoutes = require('./api/routes/data');

const app = express();

// 中间件配置
app.use(helmet());
app.use(compression());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
  credentials: true
}));

// 限流配置
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100 // 限制每个IP 15分钟内最多100个请求
});
app.use('/api/', limiter);

// 路由配置
app.use('/api/v1/spatial-analysis', spatialAnalysisRoutes);
app.use('/api/v1/geometry', geometryRoutes);
app.use('/api/v1/data', dataRoutes);

// 错误处理中间件
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    message: '内部服务器错误',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

module.exports = app;
```

### 空间分析服务
```javascript
// src/domains/spatial/spatial-analysis.service.js
const turf = require('@turf/turf');
const { Pool } = require('pg');
const redis = require('redis');

class SpatialAnalysisService {
  constructor() {
    this.db = new Pool({
      connectionString: process.env.DATABASE_URL
    });
    this.redis = redis.createClient({
      url: process.env.REDIS_URL
    });
  }

  async bufferAnalysis(geometry, radius, options = {}) {
    """缓冲区分析"""
    try {
      // 参数验证
      if (!geometry || !radius || radius <= 0) {
        throw new Error('无效的几何对象或半径');
      }

      // 缓存键
      const cacheKey = `buffer:${JSON.stringify(geometry)}:${radius}`;
      
      // 尝试从缓存获取
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return JSON.parse(cached);
      }

      // 执行缓冲区分析
      const buffered = turf.buffer(geometry, radius, options);
      
      // 计算面积
      const area = turf.area(buffered);
      
      const result = {
        geometry: buffered,
        area: area,
        radius: radius,
        unit: options.units || 'kilometers'
      };

      // 缓存结果
      await this.redis.setex(cacheKey, 3600, JSON.stringify(result));
      
      return result;
    } catch (error) {
      throw new Error(`缓冲区分析失败: ${error.message}`);
    }
  }

  async distanceAnalysis(point1, point2, options = {}) {
    """距离分析"""
    try {
      const distance = turf.distance(point1, point2, options);
      
      return {
        distance: distance,
        unit: options.units || 'kilometers',
        point1: point1,
        point2: point2
      };
    } catch (error) {
      throw new Error(`距离分析失败: ${error.message}`);
    }
  }

  async spatialQuery(geometry, relation, targetLayer, options = {}) {
    """空间查询"""
    try {
      // 构建SQL查询
      const query = `
        SELECT id, name, geometry, properties
        FROM ${targetLayer}
        WHERE ST_${relation.toUpperCase()}(geometry, ST_GeomFromGeoJSON($1))
        ${options.limit ? `LIMIT ${options.limit}` : ''}
      `;

      const result = await this.db.query(query, [JSON.stringify(geometry)]);
      
      return {
        count: result.rowCount,
        features: result.rows.map(row => ({
          id: row.id,
          name: row.name,
          geometry: row.geometry,
          properties: row.properties
        }))
      };
    } catch (error) {
      throw new Error(`空间查询失败: ${error.message}`);
    }
  }
}

module.exports = SpatialAnalysisService;
```

### API路由
```javascript
// src/api/routes/spatial-analysis.js
const express = require('express');
const router = express.Router();
const SpatialAnalysisService = require('../../domains/spatial/spatial-analysis.service');
const { validateGeometry, validateRadius } = require('../../utils/validators');

const spatialService = new SpatialAnalysisService();

// 缓冲区分析
router.post('/buffer', async (req, res) => {
  try {
    const { geometry, radius, options } = req.body;
    
    // 参数验证
    if (!validateGeometry(geometry)) {
      return res.status(400).json({
        success: false,
        message: '无效的几何对象'
      });
    }
    
    if (!validateRadius(radius)) {
      return res.status(400).json({
        success: false,
        message: '无效的半径值'
      });
    }
    
    // 执行分析
    const result = await spatialService.bufferAnalysis(geometry, radius, options);
    
    res.json({
      success: true,
      message: '缓冲区分析完成',
      data: result
    });
  } catch (error) {
    console.error('缓冲区分析错误:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// 距离分析
router.post('/distance', async (req, res) => {
  try {
    const { point1, point2, options } = req.body;
    
    const result = await spatialService.distanceAnalysis(point1, point2, options);
    
    res.json({
      success: true,
      message: '距离分析完成',
      data: result
    });
  } catch (error) {
    console.error('距离分析错误:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// 空间查询
router.post('/query', async (req, res) => {
  try {
    const { geometry, relation, targetLayer, options } = req.body;
    
    const result = await spatialService.spatialQuery(
      geometry, relation, targetLayer, options
    );
    
    res.json({
      success: true,
      message: '空间查询完成',
      data: result
    });
  } catch (error) {
    console.error('空间查询错误:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

module.exports = router;
```

## 🔄 服务间通信

### API网关配置
```python
# api-gateway/main.py
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import httpx
from typing import Dict, Any

app = FastAPI(title="SuperMap API Gateway")

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 服务发现
SERVICES = {
    "ai": "http://ai-service:8001",
    "gis": "http://gis-service:8090",
    "auth": "http://auth-service:8000"
}

@app.post("/api/v1/agent/chat")
async def chat_with_agent(request: Dict[str, Any]):
    """智能体对话 - 转发到AI服务"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{SERVICES['ai']}/api/v1/chat",
            json=request,
            timeout=30.0
        )
        return response.json()

@app.post("/api/v1/gis/buffer-analysis")
async def buffer_analysis(request: Dict[str, Any]):
    """缓冲区分析 - 转发到GIS服务"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{SERVICES['gis']}/api/v1/spatial-analysis/buffer",
            json=request,
            timeout=30.0
        )
        return response.json()

@app.post("/api/v1/gis/distance-analysis")
async def distance_analysis(request: Dict[str, Any]):
    """距离分析 - 转发到GIS服务"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{SERVICES['gis']}/api/v1/spatial-analysis/distance",
            json=request,
            timeout=30.0
        )
        return response.json()
```

## 📊 性能监控指标

### AI服务监控
- **API响应时间**: P95 < 3s (智能体处理较慢)
- **LangChain处理时间**: P95 < 5s
- **向量检索延迟**: P99 < 100ms
- **内存使用**: < 4GB

### GIS服务监控
- **API响应时间**: P95 < 500ms
- **空间计算时间**: P95 < 1s
- **数据库查询时间**: P95 < 200ms
- **缓存命中率**: > 90%

### 整体系统监控
- **服务可用性**: > 99.9%
- **错误率**: < 0.1%
- **并发处理能力**: 1000+ QPS

## 🐳 Docker部署配置

### AI服务Dockerfile
```dockerfile
# ai-service/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### GIS服务Dockerfile
```dockerfile
# gis-service/Dockerfile
FROM node:18-alpine

WORKDIR /app

# 复制package文件
COPY package*.json ./
RUN npm ci --only=production

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 3000

# 启动命令
CMD ["npm", "start"]
```

### Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  # AI服务
  ai-service:
    build: ./ai-service
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/ai_db
      - REDIS_URL=redis://redis:6379
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - postgres
      - redis
      - qdrant

  # GIS服务
  gis-service:
    build: ./gis-service
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/gis_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis

  # API网关
  api-gateway:
    build: ./api-gateway
    ports:
      - "8080:8080"
    depends_on:
      - ai-service
      - gis-service

  # 数据库
  postgres:
    image: postgis/postgis:15-3.3
    environment:
      - POSTGRES_DB=supermap
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # Redis缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  # 向量数据库
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
    volumes:
      - qdrant_data:/qdrant/storage

volumes:
  postgres_data:
  qdrant_data:
```

## 🔧 开发工具配置

### AI服务开发环境
```bash
# ai-service/requirements.txt
fastapi==0.104.1
uvicorn==0.24.0
langchain==0.1.0
openai==1.3.0
psycopg2-binary==2.9.9
redis==5.0.1
qdrant-client==1.7.0
httpx==0.25.2
pydantic==2.5.0
python-jose==3.3.0
passlib==1.7.4
```

### GIS服务开发环境
```json
// gis-service/package.json
{
  "name": "gis-analysis-service",
  "version": "1.0.0",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "compression": "^1.7.4",
    "@turf/turf": "^6.5.0",
    "pg": "^8.11.3",
    "redis": "^4.6.10",
    "bull": "^4.12.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0"
  }
}
```

这种分离架构的优势：
1. **技术栈优化**: 每个服务使用最适合的技术栈
2. **独立部署**: 服务可以独立扩展和部署
3. **故障隔离**: 单个服务故障不影响整体系统
4. **团队协作**: 不同团队可以专注于不同服务
5. **性能优化**: 针对不同服务类型进行专门优化
