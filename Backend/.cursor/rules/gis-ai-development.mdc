# GIS AI 开发综合规范

## 项目概述

本项目是一个基于SuperMap GIS的空间分析服务，采用DDD清洁架构设计，支持多种空间分析功能，包括缓冲区分析、服务区分析、最优路径分析等。

## 架构设计原则

### 1. 分层架构
- **API层**: FastAPI路由和请求处理
- **应用层**: 用例编排和DTO转换
- **领域层**: 业务逻辑和实体管理
- **基础设施层**: 数据访问和外部服务集成

### 2. 依赖倒置
- 内层不依赖外层
- 外层依赖内层接口
- 使用依赖注入容器

### 3. 单一职责
- 每个类只负责一个职责
- 方法功能单一明确
- 避免上帝类

## 核心功能模块

### 1. 分析任务管理
- 任务创建、查询、更新、删除
- 任务状态跟踪（pending, processing, completed, failed, cancelled）
- 任务进度管理
- 异步任务处理

### 2. 空间分析功能
- 缓冲区分析 (Buffer Analysis)
- 最短路径分析 (Shortest Path Analysis)
- 叠加分析 (Overlay Analysis)
- 自定义分析类型

### 3. SuperMap服务集成
- 网络分析服务集成
- 空间分析服务集成
- 服务配置管理
- 错误处理和重试机制

## 代码结构规范

### 1. 文件组织
```
analysis/
├── api/v1/analysis/           # API接口层
├── application/               # 应用层
│   ├── dto/                  # 数据传输对象
│   └── use_cases/            # 用例实现
├── domains/                   # 领域层
│   └── analysis/             # 分析领域
│       ├── entities.py       # 实体定义
│       ├── services.py       # 领域服务
│       └── repositories.py   # 仓储接口
├── infrastructure/            # 基础设施层
│   ├── database/             # 数据库相关
│   └── external/             # 外部服务集成
└── core/                     # 核心配置
    ├── config.py             # 配置管理
    ├── database.py           # 数据库连接
    └── container.py          # 依赖注入容器
```

### 2. 命名规范
- 文件名: snake_case
- 类名: PascalCase
- 函数名: snake_case
- 常量: UPPER_CASE
- 变量: snake_case

## 开发规范

### 1. Python编码标准
- 遵循PEP 8规范
- 使用类型注解
- 异步编程优先
- 完整的错误处理
- 详细的文档字符串

### 2. FastAPI开发规范
- 统一的响应格式
- 完整的参数验证
- 错误处理中间件
- API文档自动生成
- 依赖注入使用

### 3. 数据库设计规范
- 使用PostgreSQL + JSONB
- 异步数据库操作
- 事务管理
- 索引优化
- 数据迁移支持

### 4. 测试规范
- 单元测试覆盖
- 集成测试
- 端到端测试
- 测试数据管理
- 测试覆盖率报告

## 实际代码实现参考

### 1. 分析任务创建流程

#### API接口
```python
@router.post("/tasks", response_model=Dict[str, Any])
async def create_analysis_task(
    task_data: AnalysisTaskCreateDTO,
    session = Depends(get_db)
) -> Dict[str, Any]:
    """创建分析任务"""
    try:
        analysis_use_case = build_analysis_use_case(session)
        created_by = "test_user"  # 从JWT token获取
        result = await analysis_use_case.create_analysis_task(task_data, created_by)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="创建分析任务失败")
```

#### 用例实现
```python
class AnalysisUseCase:
    async def create_analysis_task(
        self,
        task_data: AnalysisTaskCreateDTO,
        created_by: str
    ) -> Dict[str, Any]:
        """创建分析任务"""
        task = await self.analysis_service.create_analysis_task(
            name=task_data.name,
            analysis_type=task_data.analysis_type,
            parameters=task_data.parameters,
            created_by=created_by,
            description=task_data.description
        )
        
        return {
            "success": True,
            "message": "分析任务创建成功",
            "data": AnalysisTaskResponseDTO(**task.to_dict())
        }
```

#### 领域服务
```python
class AnalysisService:
    async def create_analysis_task(
        self,
        name: str,
        analysis_type: AnalysisType,
        parameters: Dict[str, Any],
        created_by: str,
        description: Optional[str] = None
    ) -> AnalysisTask:
        """创建分析任务"""
        task = AnalysisTask.create_new(
            name=name,
            analysis_type=analysis_type,
            parameters=parameters,
            created_by=created_by,
            description=description
        )
        return await self.task_repository.create(task)
```

### 2. 任务状态管理

#### 状态更新
```python
async def update_task_status(
    self,
    task_id: UUID,
    status: AnalysisStatus,
    supermap_result: Optional[SuperMapResult] = None,
    error_message: Optional[str] = None
) -> Optional[AnalysisTask]:
    """更新任务状态"""
    task = await self.task_repository.get_by_id(task_id)
    if not task:
        return None
    
    if status == AnalysisStatus.PROCESSING:
        task.start_processing()
    elif status == AnalysisStatus.COMPLETED and supermap_result:
        task.complete(supermap_result)
    elif status == AnalysisStatus.FAILED:
        task.fail(error_message or "分析失败", supermap_result)
    elif status == AnalysisStatus.CANCELLED:
        task.cancel()
    
    return await self.task_repository.update(task)
```

#### 进度更新
```python
async def update_task_progress(self, task_id: UUID, progress: float) -> Optional[AnalysisTask]:
    """更新任务进度"""
    task = await self.task_repository.get_by_id(task_id)
    if not task:
        return None
    
    task.update_progress(progress)
    return await self.task_repository.update(task)
```

### 3. SuperMap服务集成

#### 服务工厂
```python
class SuperMapServiceFactory:
    @staticmethod
    def create_network_analyst_service(config: Dict[str, Any]):
        """创建网络分析服务"""
        return SuperMapNetworkAnalystService(
            service_url=config["service_url"],
            dataset=config["dataset"],
            weight_field=config["weight_field"],
            timeout=config.get("timeout", 30000)
        )
```

#### 网络分析服务
```python
class SuperMapNetworkAnalystService:
    async def find_service_areas(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """查找服务区"""
        try:
            request_params = self._build_service_area_params(parameters)
            response = await self._call_supermap_service(
                method="findServiceAreas",
                parameters=request_params
            )
            
            return {
                "success": True,
                "data": response,
                "service_type": "network_analyst",
                "method": "findServiceAreas"
            }
        except Exception as e:
            return {
                "success": False,
                "error_message": str(e),
                "service_type": "network_analyst",
                "method": "findServiceAreas"
            }
```

## 配置管理

### 1. 环境配置
```python
class Settings(BaseSettings):
    PROJECT_NAME: str = "SuperMap GIS 分析服务"
    VERSION: str = "1.0.0"
    DESCRIPTION: str = "基于SuperMap的空间分析服务"
    API_V1_STR: str = "/api/v1"
    DATABASE_URL: str
    ALLOWED_HOSTS: List[str] = ["*"]
    SUPERMAP_BASE_URL: str
    SUPERMAP_API_KEY: str
    LOG_LEVEL: str = "INFO"
```

### 2. SuperMap服务配置
```json
{
  "supermap_services": {
    "network_analyst": {
      "service_url": "https://iserver.supermap.io/iserver/services/networkanalyst-changchun/restjsr/networkanalyst",
      "dataset": "RoadNet@Changchun",
      "weight_field": "length",
      "timeout": 30000
    },
    "spatial_analyst": {
      "service_url": "https://iserver.supermap.io/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst",
      "timeout": 30000
    }
  }
}
```

## 错误处理

### 1. 错误码定义
- `INVALID_TASK_ID`: 无效的任务ID
- `TASK_NOT_FOUND`: 任务不存在
- `INVALID_STATUS`: 无效的状态值
- `INVALID_ANALYSIS_TYPE`: 无效的分析类型
- `ANALYSIS_FAILED`: 分析失败
- `SUPERMAP_SERVICE_ERROR`: SuperMap服务错误
- `SERVICE_UNAVAILABLE`: 服务不可用

### 2. 错误响应格式
```json
{
  "success": false,
  "message": "错误描述",
  "error_code": "ERROR_CODE",
  "details": {
    "field": "错误字段",
    "reason": "具体错误原因"
  }
}
```

## 性能优化

### 1. 异步处理
- 支持任务异步处理
- 实现任务进度实时更新
- 提供任务队列管理
- 支持任务优先级设置

### 2. 缓存策略
- Redis缓存支持
- 内存缓存优化
- 缓存失效策略
- 缓存预热机制

### 3. 数据库优化
- 连接池管理
- 查询优化
- 索引策略
- 分页查询

## 监控和日志

### 1. 日志记录
- 结构化日志
- 日志级别管理
- 日志文件轮转
- 日志聚合分析

### 2. 性能监控
- 请求响应时间
- 数据库查询性能
- 外部服务调用性能
- 系统资源使用情况

### 3. 错误监控
- 错误率统计
- 错误分类分析
- 错误告警机制
- 错误追踪分析

## 开发检查清单

### 新功能开发
- [ ] 是否遵循分层架构原则
- [ ] 是否在正确的层次实现功能
- [ ] 是否使用依赖注入
- [ ] 是否定义清晰的接口
- [ ] 是否实现完整的错误处理
- [ ] 是否包含单元测试
- [ ] 是否遵循命名规范
- [ ] 是否包含完整的文档

### API接口开发
- [ ] 是否使用正确的HTTP方法
- [ ] 是否定义完整的请求/响应模型
- [ ] 是否包含参数验证
- [ ] 是否实现错误处理
- [ ] 是否使用依赖注入
- [ ] 是否包含API文档
- [ ] 是否支持分页查询
- [ ] 是否实现异步处理

### SuperMap服务集成
- [ ] 是否正确配置SuperMap服务URL
- [ ] 是否包含完整的结果设置参数
- [ ] 是否实现数据格式转换
- [ ] 是否包含错误处理机制
- [ ] 是否支持异步任务处理
- [ ] 是否保存SuperMap请求和结果
- [ ] 是否实现任务状态跟踪
- [ ] 是否包含超时处理

## 部署和运维

### 1. 容器化部署
- Docker镜像构建
- 容器编排配置
- 环境变量管理
- 健康检查配置

### 2. 数据库管理
- 数据库初始化
- 数据迁移脚本
- 备份恢复策略
- 性能调优配置

### 3. 监控告警
- 系统监控配置
- 告警规则设置
- 日志收集分析
- 性能指标监控

## 总结

本规范基于实际代码实现，整合了DDD清洁架构、FastAPI开发、Python编码标准、SuperMap服务集成等多个方面的最佳实践。开发团队应严格遵循这些规范，确保代码质量、系统性能和可维护性。
