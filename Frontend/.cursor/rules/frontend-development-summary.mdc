# SuperMap 前端开发规范总结

## 概述

本文档整合了 SuperMap 前端项目的所有开发规范，为开发者提供完整的开发指导。

## 核心规范文件

### 1. 项目架构规范
- **文件**: [`project-architecture.mdc`](mdc:.cursor/rules/project-architecture.mdc)
- **内容**: 项目结构、技术栈、开发规范、状态管理架构、API设计规范

### 2. 前端核心规范
- **文件**: [`supermap-frontend.mdc`](mdc:.cursor/rules/supermap-frontend.mdc)
- **内容**: 全局约定、选择与IO、地图交互、绘制与几何、Store管理

### 3. 分析功能模式
- **文件**: [`analysis-function-pattern.mdc`](mdc:.cursor/rules/analysis-function-pattern.mdc)
- **内容**: 分析功能标准架构、状态管理、图层显示、保存导出

### 4. Vue组合式函数规范
- **文件**: [`vue-composables.mdc`](mdc:.cursor/rules/vue-composables.mdc)
- **内容**: 组合式函数开发标准、状态管理、Store集成、异步操作

### 5. Vue组件规范
- **文件**: [`vue-components.mdc`](mdc:.cursor/rules/vue-components.mdc)
- **内容**: 组件结构、Props/Emits、状态管理、样式规范、性能优化

### 6. 选择要素IO规范
- **文件**: [`selection-io.mdc`](mdc:.cursor/rules/selection-io.mdc)
- **内容**: 要素选择格式、序列化、保存读取API

## 快速开发指南

### 1. 创建新分析功能

#### 步骤1: 创建组合式函数
```typescript
// src/composables/use[NewAnalysis].ts
export function use[NewAnalysis]Analysis() {
  // 遵循 vue-composables.mdc 规范
  const analysisSettings = ref({})
  const analysisResults = ref([])
  
  const performAnalysis = async () => {
    // 实现分析逻辑
  }
  
  return {
    analysisSettings,
    analysisResults,
    performAnalysis
  }
}
```

#### 步骤2: 创建面板组件
```vue
<!-- src/views/dashboard/traditional/tools/[NewAnalysis]Panel.vue -->
<template>
  <div class="analysis-panel">
    <!-- 遵循 vue-components.mdc 规范 -->
  </div>
</template>

<script setup lang="ts">
import { use[NewAnalysis]Analysis } from '@/composables/use[NewAnalysis]Analysis'
// 实现组件逻辑
</script>
```

#### 步骤3: 集成到Store
```typescript
// 在 analysisStore.ts 中添加新工具
const openTool = (toolId: string, toolName: string) => {
  toolPanel.value.visible = true
  toolPanel.value.currentTool = toolId
  toolPanel.value.currentToolName = toolName
}
```

### 2. 创建新组件

#### 基本结构
```vue
<template>
  <div class="component-name">
    <!-- 组件内容 -->
  </div>
</template>

<script setup lang="ts" name="ComponentName">
// 遵循 vue-components.mdc 规范
interface Props {
  title: string
  visible?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  visible: false
})

const emit = defineEmits<{
  'update:visible': [value: boolean]
}>()
</script>

<style scoped>
.component-name {
  /* 使用主题变量，禁止硬编码颜色 */
  background-color: var(--panel-bg);
  color: var(--text-color);
}
</style>
```

### 3. 创建新Store

#### 基本结构
```typescript
// src/stores/[storeName]Store.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const use[StoreName]Store = defineStore('[storeName]', () => {
  // 状态
  const data = ref([])
  const isLoading = ref(false)
  
  // 计算属性
  const hasData = computed(() => data.value.length > 0)
  
  // 方法
  const fetchData = async () => {
    // 实现逻辑
  }
  
  return {
    data,
    isLoading,
    hasData,
    fetchData
  }
})
```

## 开发检查清单

### 代码质量检查
- [ ] 使用 TypeScript 类型定义
- [ ] 遵循命名规范（PascalCase 组件，camelCase 函数）
- [ ] 使用主题变量，禁止硬编码颜色
- [ ] 实现错误处理机制
- [ ] 添加必要的注释和文档

### 性能检查
- [ ] 使用计算属性优化复杂计算
- [ ] 实现懒加载和代码分割
- [ ] 及时清理事件监听器和定时器
- [ ] 避免内存泄漏

### 用户体验检查
- [ ] 支持响应式设计
- [ ] 实现加载状态和错误提示
- [ ] 支持键盘导航
- [ ] 提供用户友好的错误信息

### 测试检查
- [ ] 编写单元测试
- [ ] 测试组件交互
- [ ] 测试错误处理
- [ ] 测试性能边界

## 常用代码片段

### 1. 响应式状态管理
```typescript
// 基本状态
const isLoading = ref(false)
const data = ref([])
const error = ref(null)

// 对象状态
const formState = reactive({
  username: '',
  password: ''
})

// 计算属性
const hasData = computed(() => data.value.length > 0)
```

### 2. 异步操作处理
```typescript
const fetchData = async () => {
  try {
    isLoading.value = true
    error.value = null
    
    const result = await api.getData()
    data.value = result
    
  } catch (err) {
    error.value = err instanceof Error ? err.message : '请求失败'
  } finally {
    isLoading.value = false
  }
}
```

### 3. 事件处理
```typescript
const emit = defineEmits<{
  'update:visible': [value: boolean]
  'data-change': [data: any[]]
}>()

const handleChange = (newValue: any) => {
  emit('data-change', newValue)
}
```

### 4. 样式变量使用
```css
.component {
  background-color: var(--panel-bg);
  border: 1px solid var(--border-color);
  color: var(--text-color);
  padding: var(--spacing-md);
  font-size: var(--font-size-md);
}
```

## 开发工具配置

### 1. VS Code 扩展
- Volar (Vue 3 支持)
- TypeScript Importer
- ESLint
- Prettier
- Auto Rename Tag

### 2. 代码格式化
```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

### 3. ESLint 配置
```json
// .eslintrc
{
  "extends": [
    "@vue/typescript/recommended",
    "@vue/prettier",
    "@vue/prettier/@typescript-eslint"
  ]
}
```

## 常见问题解决

### 1. 响应式问题
```typescript
// 问题：数组更新不触发响应
const items = ref([])

// 解决方案1：使用展开运算符
items.value = [...items.value, newItem]

// 解决方案2：使用 push
items.value.push(newItem)

// 解决方案3：强制触发响应
items.value = items.value.slice()
```

### 2. 类型定义问题
```typescript
// 问题：类型推断不准确
const data = ref([]) // 类型为 never[]

// 解决方案：明确类型
const data = ref<any[]>([])
const data = ref<Data[]>([])
```

### 3. 组件通信问题
```typescript
// 问题：父子组件数据同步
// 解决方案：使用 v-model 或 watch
watch(() => props.value, (newValue) => {
  localValue.value = newValue
})
```

## 性能优化建议

### 1. 组件优化
- 使用 `defineAsyncComponent` 懒加载组件
- 使用 `v-memo` 优化列表渲染
- 合理使用 `shallowRef` 和 `shallowReactive`

### 2. 计算属性优化
- 避免在计算属性中执行复杂操作
- 使用缓存机制处理大量数据
- 避免创建新对象

### 3. 事件处理优化
- 使用防抖和节流处理频繁事件
- 及时清理事件监听器
- 使用事件委托处理大量元素

## 部署和构建

### 1. 构建配置
```typescript
// vite.config.js
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          map: ['ol'],
          ui: ['ant-design-vue']
        }
      }
    }
  }
})
```

### 2. 环境变量
```bash
# .env.production
VITE_API_BASE_URL=https://api.example.com
VITE_MAP_SERVICE_URL=https://map.example.com
```

### 3. 静态资源处理
- 图片使用 WebP 格式
- 字体文件使用 `font-display: swap`
- 大文件使用 CDN 加速

## 总结

遵循这些规范可以确保：
1. 代码质量和一致性
2. 开发效率和可维护性
3. 用户体验和性能
4. 团队协作和知识传承

建议开发者：
1. 仔细阅读所有规范文档
2. 在开发过程中经常参考规范
3. 发现规范问题及时反馈和更新
4. 新功能开发严格遵循规范要求
description:
globs:
alwaysApply: true
---
