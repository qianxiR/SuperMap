# Vue3 组件开发规范

## 概述

本规范定义了在 SuperMap 前端项目中开发 Vue 3 组件的标准，包括组件结构、命名规范、样式规范等。

## 组件结构

### 1. 基本模板
```vue
<template>
  <div class="component-name">
    <!-- 组件内容 -->
  </div>
</template>

<script setup lang="ts" name="ComponentName">
// 导入
import { ref, computed, watch, onMounted, onUnmounted } from 'vue'
import { useStore } from '@/stores/storeName'
import type { ComponentProps, ComponentEmits } from '@/types/component'

// 类型定义
interface Props {
  title: string
  visible?: boolean
  data?: any[]
}

interface Emits {
  'update:visible': [value: boolean]
  'data-change': [data: any[]]
  'close': []
}

// 组件逻辑
const props = withDefaults(defineProps<Props>(), {
  visible: false,
  data: () => []
})

const emit = defineEmits<Emits>()

// 组合式函数
const { data, methods } = useStore()

// 响应式状态
const localVisible = ref(props.visible)
const localData = ref(props.data)

// 计算属性
const hasData = computed(() => localData.value.length > 0)
const displayTitle = computed(() => props.title || '默认标题')

// 监听器
watch(() => props.visible, (newValue) => {
  localVisible.value = newValue
})

watch(localVisible, (newValue) => {
  emit('update:visible', newValue)
})

// 方法
const handleClose = () => {
  localVisible.value = false
  emit('close')
}

const handleDataChange = (newData: any[]) => {
  localData.value = newData
  emit('data-change', newData)
}

// 生命周期
onMounted(() => {
  // 初始化逻辑
})

onUnmounted(() => {
  // 清理逻辑
})
</script>

<style scoped>
.component-name {
  /* 组件样式 */
}
</style>
```

### 2. 组件命名
- 使用 PascalCase 命名组件
- 文件名与组件名保持一致
- 示例：`BufferAnalysisPanel.vue` → `BufferAnalysisPanel`

### 3. 目录结构
```
src/components/
├── Layout/           # 布局组件
│   ├── Header.vue
│   ├── Sidebar.vue
│   └── Footer.vue
├── Map/              # 地图相关组件
│   ├── MapContainer.vue
│   ├── MapControls.vue
│   └── MapLayers.vue
└── UI/               # 通用 UI 组件
    ├── Button.vue
    ├── Input.vue
    └── Modal.vue
```

## Props 和 Emits 规范

### 1. Props 定义
```typescript
interface Props {
  // 必需属性
  title: string
  data: any[]
  
  // 可选属性
  visible?: boolean
  size?: 'small' | 'medium' | 'large'
  theme?: 'light' | 'dark'
  
  // 带默认值的属性
  disabled?: boolean
  loading?: boolean
}

// 使用 withDefaults 设置默认值
const props = withDefaults(defineProps<Props>(), {
  visible: false,
  size: 'medium',
  theme: 'light',
  disabled: false,
  loading: false
})
```

### 2. Emits 定义
```typescript
interface Emits {
  // 更新事件
  'update:visible': [value: boolean]
  'update:data': [data: any[]]
  
  // 自定义事件
  'click': [event: MouseEvent]
  'change': [value: any, oldValue: any]
  'submit': [formData: any]
  
  // 生命周期事件
  'mounted': []
  'unmounted': []
}

const emit = defineEmits<Emits>()

// 使用 emit
const handleClick = (event: MouseEvent) => {
  emit('click', event)
}

const handleChange = (newValue: any, oldValue: any) => {
  emit('change', newValue, oldValue)
}
```

### 3. 双向绑定
```vue
<template>
  <div class="input-component">
    <input 
      :value="modelValue" 
      @input="handleInput"
      @change="handleChange"
    />
  </div>
</template>

<script setup lang="ts">
interface Props {
  modelValue: string
}

interface Emits {
  'update:modelValue': [value: string]
  'change': [value: string]
}

const props = defineProps<Props>()
const emit = defineEmits<Emits>()

const handleInput = (event: Event) => {
  const value = (event.target as HTMLInputElement).value
  emit('update:modelValue', value)
}

const handleChange = (event: Event) => {
  const value = (event.target as HTMLInputElement).value
  emit('change', value)
}
</script>
```

## 状态管理

### 1. 本地状态
```typescript
// 组件内部状态
const localState = ref({
  isLoading: false,
  error: null,
  data: []
})

// 表单状态
const formState = reactive({
  username: '',
  password: '',
  remember: false
})

// 列表状态
const listState = ref({
  items: [],
  total: 0,
  currentPage: 1,
  pageSize: 10
})
```

### 2. Store 集成
```typescript
import { useMapStore } from '@/stores/mapStore'
import { useAnalysisStore } from '@/stores/analysisStore'

const mapStore = useMapStore()
const analysisStore = useAnalysisStore()

// 读取状态
const map = computed(() => mapStore.map)
const currentTool = computed(() => analysisStore.currentTool)

// 调用方法
const addLayer = (layer: Layer) => {
  mapStore.addLayer(layer)
}

const openTool = (toolId: string) => {
  analysisStore.openTool(toolId)
}
```

### 3. 状态持久化
```typescript
// 使用 localStorage 持久化组件状态
const usePersistentState = <T>(key: string, defaultValue: T) => {
  const stored = localStorage.getItem(key)
  const state = ref<T>(stored ? JSON.parse(stored) : defaultValue)
  
  watch(state, (newValue) => {
    localStorage.setItem(key, JSON.stringify(newValue))
  }, { deep: true })
  
  return state
}

// 使用示例
const componentSettings = usePersistentState('component-settings', {
  collapsed: false,
  size: 'medium'
})
```

## 事件处理

### 1. 事件命名
```typescript
// 使用 kebab-case 命名事件
const emit = defineEmits<{
  'item-click': [item: any]
  'form-submit': [formData: any]
  'selection-change': [selection: any[]]
}>()

// 事件处理函数命名
const handleItemClick = (item: any) => {
  emit('item-click', item)
}

const handleFormSubmit = (formData: any) => {
  emit('form-submit', formData)
}

const handleSelectionChange = (selection: any[]) => {
  emit('selection-change', selection)
}
```

### 2. 事件修饰符
```vue
<template>
  <!-- 阻止默认行为 -->
  <button @click.prevent="handleClick">点击</button>
  
  <!-- 阻止事件冒泡 -->
  <div @click.stop="handleDivClick">
    <button @click="handleButtonClick">按钮</button>
  </div>
  
  <!-- 只触发一次 -->
  <button @click.once="handleOnceClick">一次性点击</button>
  
  <!-- 键盘事件 -->
  <input @keyup.enter="handleEnter" @keyup.esc="handleEscape" />
</template>
```

### 3. 自定义事件
```typescript
// 创建自定义事件
const createCustomEvent = (name: string, detail: any) => {
  const event = new CustomEvent(name, {
    detail,
    bubbles: true,
    cancelable: true
  })
  
  return event
}

// 使用自定义事件
const handleCustomAction = () => {
  const event = createCustomEvent('custom-action', { data: 'some data' })
  document.dispatchEvent(event)
}
```

## 样式规范

### 1. CSS 变量使用
```vue
<style scoped>
.component {
  /* 使用主题变量，禁止硬编码颜色 */
  background-color: var(--panel-bg);
  border: 1px solid var(--border-color);
  color: var(--text-color);
  
  /* 使用主题间距 */
  padding: var(--spacing-md);
  margin: var(--spacing-sm);
  
  /* 使用主题字体 */
  font-family: var(--font-family);
  font-size: var(--font-size-md);
}

/* 响应式设计 */
@media (max-width: 768px) {
  .component {
    padding: var(--spacing-sm);
    font-size: var(--font-size-sm);
  }
}

/* 暗色模式支持 */
@media (prefers-color-scheme: dark) {
  .component {
    background-color: var(--panel-bg-dark);
    color: var(--text-color-dark);
  }
}
</style>
```

### 2. 样式作用域
```vue
<style scoped>
/* 组件样式 */
.component {
  /* 基础样式 */
}

/* 子元素样式 */
.component__header {
  /* 头部样式 */
}

.component__body {
  /* 主体样式 */
}

.component__footer {
  /* 底部样式 */
}

/* 状态样式 */
.component--loading {
  /* 加载状态 */
}

.component--disabled {
  /* 禁用状态 */
}

.component--error {
  /* 错误状态 */
}
</style>
```

### 3. 动态样式
```vue
<template>
  <div 
    class="component"
    :class="{
      'component--loading': isLoading,
      'component--disabled': disabled,
      'component--error': hasError
    }"
    :style="componentStyle"
  >
    内容
  </div>
</template>

<script setup lang="ts">
const isLoading = ref(false)
const disabled = ref(false)
const hasError = ref(false)

const componentStyle = computed(() => ({
  '--component-width': props.width || '100%',
  '--component-height': props.height || 'auto'
}))
</script>
```

## 性能优化

### 1. 懒加载
```vue
<script setup lang="ts">
// 按需导入大型组件
const HeavyComponent = defineAsyncComponent(() => 
  import('./HeavyComponent.vue')
)

// 按需导入大型依赖
const loadHeavyLibrary = async () => {
  const { default: HeavyLibrary } = await import('heavy-library')
  return new HeavyLibrary()
}
</script>
```

### 2. 计算属性优化
```typescript
// 避免在模板中执行复杂计算
const expensiveComputation = computed(() => {
  // 使用缓存或分页处理大量数据
  return data.value.slice(0, 1000).map(item => /* 处理逻辑 */)
})

// 避免在计算属性中创建新对象
const objectComputation = computed(() => {
  // 错误示例：每次都创建新对象
  // return { ...data.value, computed: true }
  
  // 正确示例：使用缓存
  if (!data.value.length) return {}
  return {
    items: data.value,
    count: data.value.length,
    computed: true
  }
})
```

### 3. 列表渲染优化
```vue
<template>
  <!-- 使用 v-memo 优化列表渲染 -->
  <div v-for="item in items" :key="item.id" v-memo="[item.id, item.updated]">
    <ListItem :item="item" @update="handleItemUpdate" />
  </div>
  
  <!-- 虚拟滚动处理大量数据 -->
  <VirtualList 
    :items="largeItems" 
    :item-height="50"
    @scroll="handleScroll"
  />
</template>
```

## 错误处理

### 1. 错误边界
```vue
<template>
  <div class="component">
    <ErrorBoundary v-if="hasError" :error="error" @retry="handleRetry" />
    <div v-else>
      <!-- 正常内容 -->
    </div>
  </div>
</template>

<script setup lang="ts">
const hasError = ref(false)
const error = ref<Error | null>(null)

const handleError = (err: Error) => {
  hasError.value = true
  error.value = err
  console.error('组件错误:', err)
}

const handleRetry = () => {
  hasError.value = false
  error.value = null
  // 重试逻辑
}
</script>
```

### 2. 异步错误处理
```typescript
const handleAsyncOperation = async () => {
  try {
    isLoading.value = true
    error.value = null
    
    const result = await api.operation()
    data.value = result
    
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : '操作失败'
    error.value = errorMessage
    console.error('异步操作失败:', err)
    
    // 显示用户友好的错误信息
    showErrorMessage(errorMessage)
    
  } finally {
    isLoading.value = false
  }
}
```

## 测试规范

### 1. 组件测试
```typescript
// __tests__/ComponentName.test.ts
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import ComponentName from '@/components/ComponentName.vue'

describe('ComponentName', () => {
  it('should render correctly', () => {
    const wrapper = mount(ComponentName, {
      props: {
        title: '测试标题'
      }
    })
    
    expect(wrapper.text()).toContain('测试标题')
  })
  
  it('should emit events correctly', async () => {
    const wrapper = mount(ComponentName)
    
    await wrapper.find('button').trigger('click')
    
    expect(wrapper.emitted('click')).toBeTruthy()
  })
})
```

### 2. 测试工具
```typescript
// 模拟 Store
vi.mock('@/stores/storeName', () => ({
  useStore: () => ({
    data: ref([]),
    methods: vi.fn()
  })
}))

// 模拟 API
vi.mock('@/api/apiName', () => ({
  fetchData: vi.fn()
}))

// 模拟事件
const mockEmit = vi.fn()
const mockProps = {
  title: '测试标题'
}
```

## 最佳实践

### 1. 单一职责
- 每个组件只负责一个特定功能
- 避免在一个组件中混合多个不相关的逻辑
- 将复杂逻辑提取到组合式函数中

### 2. 可复用性
- 设计通用的组件接口
- 支持插槽和属性传递
- 避免硬编码业务逻辑

### 3. 可维护性
- 使用清晰的命名约定
- 添加必要的注释和文档
- 遵循 DRY 原则

### 4. 可访问性
- 支持键盘导航
- 提供 ARIA 标签
- 支持屏幕阅读器

### 5. 响应式设计
- 支持不同屏幕尺寸
- 使用 CSS 媒体查询
- 测试移动端体验

### 6. 国际化
- 支持多语言
- 使用 i18n 工具
- 避免硬编码文本
description:
globs:
alwaysApply: true
---
