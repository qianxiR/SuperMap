---
description:
# Vue3代码生成规范

## 1. Vue3核心语法代码生成

### 1.1 setup语法糖组件模板
```vue
<template>
  <div class="component-name">
    <h2>姓名：{{name}}</h2>
    <h2>年龄：{{age}}</h2>
    <button @click="changeName">修改名字</button>
    <button @click="changeAge">年龄+1</button>
  </div>
</template>

<script setup lang="ts" name="ComponentName">
import { ref, reactive, computed, watch, onMounted } from 'vue'

// 响应式数据 - ref用于基本类型
const name = ref('张三')
const age = ref(18)

// 响应式数据 - reactive用于对象类型
const person = reactive({
  car: { brand: '奔驰', price: 100 },
  games: [
    { id: '1', name: '英雄联盟' },
    { id: '2', name: '王者荣耀' }
  ]
})

// 计算属性
const fullName = computed(() => {
  return name.value + '-computed'
})

// 方法
const changeName = () => {
  name.value = '李四'
}

const changeAge = () => {
  age.value += 1
}

// 生命周期
onMounted(() => {
  console.log('组件挂载完成')
})
</script>
```

### 1.2 ref vs reactive使用规范
```typescript
// 基本类型 - 使用ref
const count = ref(0)
const message = ref('hello')
const isVisible = ref(true)

// 对象类型 - 推荐使用reactive
const user = reactive({
  name: '张三',
  age: 18,
  address: {
    city: '北京',
    street: '长安街'
  }
})

// 对象类型 - 也可使用ref（需要.value）
const userRef = ref({
  name: '李四',
  age: 20
})
```

### 1.3 computed计算属性模板
```typescript
// 只读计算属性
const fullName = computed(() => {
  return firstName.value + ' ' + lastName.value
})

// 可读可写计算属性
const fullNameWritable = computed({
  get() {
    return firstName.value + ' ' + lastName.value
  },
  set(value) {
    const names = value.split(' ')
    firstName.value = names[0]
    lastName.value = names[1]
  }
})
```

### 1.4 watch监听器模板
```typescript
// 监听ref基本类型
watch(count, (newValue, oldValue) => {
  console.log('count变化:', newValue, oldValue)
})

// 监听ref对象类型（需要深度监听）
watch(userRef, (newValue, oldValue) => {
  console.log('userRef变化:', newValue, oldValue)
}, { deep: true })

// 监听reactive对象
watch(user, (newValue, oldValue) => {
  console.log('user变化:', newValue, oldValue)
})

// 监听对象属性
watch(() => user.name, (newValue, oldValue) => {
  console.log('user.name变化:', newValue, oldValue)
})

// 监听多个数据
watch([count, () => user.name], ([newCount, newName], [oldCount, oldName]) => {
  console.log('多个数据变化')
})
```

### 1.5 watchEffect模板
```typescript
// 自动追踪依赖
const stopWatch = watchEffect(() => {
  if (count.value >= 10 || user.age >= 20) {
    console.log('触发条件满足')
  }
  
  // 可以访问DOM
  const element = document.getElementById('demo')
  if (element) {
    element.textContent = `Count: ${count.value}`
  }
})

// 停止监听
const stopListening = () => {
  stopWatch()
}
```

### 1.6 模板引用ref模板
```vue
<template>
  <div>
    <h1 ref="titleRef">标题</h1>
    <input ref="inputRef" type="text" />
    <button @click="focusInput">聚焦输入框</button>
    
    <!-- 组件引用 -->
    <ChildComponent ref="childRef" />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import ChildComponent from './ChildComponent.vue'

// 模板引用
const titleRef = ref<HTMLElement>()
const inputRef = ref<HTMLInputElement>()
const childRef = ref<InstanceType<typeof ChildComponent>>()

const focusInput = () => {
  inputRef.value?.focus()
}

onMounted(() => {
  console.log(titleRef.value?.textContent)
  console.log(childRef.value?.childMethod())
})
</script>
```

## 2. 路由代码生成

### 2.1 路由配置模板
```typescript
import { createRouter, createWebHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    redirect: '/home'
  },
  {
    path: '/home',
    name: 'Home',
    component: () => import('@/views/Home.vue'),
    meta: {
      title: '首页',
      requiresAuth: false
    }
  },
  {
    path: '/news',
    name: 'News',
    component: () => import('@/views/News.vue'),
    children: [
      {
        path: 'detail/:id',
        name: 'NewsDetail',
        component: () => import('@/views/NewsDetail.vue'),
        props: true
      }
    ]
  }
]

export default createRouter({
  history: createWebHistory(),
  routes
})
```

### 2.2 路由组件模板
```vue
<template>
  <div class="news">
    <nav class="news-list">
      <RouterLink 
        v-for="news in newsList" 
        :key="news.id" 
        :to="{ 
          name: 'NewsDetail', 
          params: { id: news.id },
          query: { title: news.title }
        }"
      >
        {{ news.title }}
      </RouterLink>
    </nav>
    <div class="news-detail">
      <RouterView />
    </div>
  </div>
</template>

<script setup lang="ts">
import { RouterLink, RouterView, useRouter, useRoute } from 'vue-router'
import { reactive } from 'vue'

const router = useRouter()
const route = useRoute()

const newsList = reactive([
  { id: '1', title: '新闻1' },
  { id: '2', title: '新闻2' }
])

// 编程式导航
const goToDetail = (id: string) => {
  router.push({
    name: 'NewsDetail',
    params: { id },
    query: { from: 'list' }
  })
}
</script>
```

### 2.3 路由参数接收模板
```vue
<template>
  <div class="detail">
    <h2>新闻详情</h2>
    <p>ID: {{ id }}</p>
    <p>标题: {{ title }}</p>
    <p>来源: {{ from }}</p>
  </div>
</template>

<script setup lang="ts">
import { useRoute } from 'vue-router'

// 接收路由参数
const route = useRoute()

// params参数
const id = route.params.id

// query参数
const title = route.query.title
const from = route.query.from

// 如果配置了props: true，可以直接接收props
interface Props {
  id: string
}

const props = defineProps<Props>()
</script>
```

## 3. Pinia状态管理代码生成

### 3.1 Store定义模板
```typescript
import { defineStore } from 'pinia'
import { ref, reactive, computed } from 'vue'

// Options API风格
export const useCountStore = defineStore('count', {
  state: () => ({
    sum: 0,
    school: 'atguigu'
  }),
  
  getters: {
    bigSum: (state) => state.sum * 10,
    upperSchool(): string {
      return this.school.toUpperCase()
    }
  },
  
  actions: {
    increment(value: number) {
      if (this.sum < 10) {
        this.sum += value
      }
    },
    decrement(value: number) {
      if (this.sum > 1) {
        this.sum -= value
      }
    }
  }
})

// Composition API风格
export const useUserStore = defineStore('user', () => {
  // 状态
  const user = ref({ name: '', age: 0 })
  const isLoggedIn = ref(false)
  
  // 计算属性
  const userInfo = computed(() => {
    return `${user.value.name} (${user.value.age})`
  })
  
  // 方法
  const login = (userData: { name: string; age: number }) => {
    user.value = userData
    isLoggedIn.value = true
  }
  
  const logout = () => {
    user.value = { name: '', age: 0 }
    isLoggedIn.value = false
  }
  
  return {
    user,
    isLoggedIn,
    userInfo,
    login,
    logout
  }
})
```

### 3.2 Store使用模板
```vue
<template>
  <div class="store-demo">
    <h2>当前求和为：{{ sum }}</h2>
    <h2>放大10倍：{{ bigSum }}</h2>
    <h2>学校：{{ upperSchool }}</h2>
    
    <button @click="increment(1)">+1</button>
    <button @click="decrement(1)">-1</button>
    
    <hr>
    
    <h2>用户信息：{{ userInfo }}</h2>
    <button @click="login({ name: '张三', age: 18 })">登录</button>
    <button @click="logout">登出</button>
  </div>
</template>

<script setup lang="ts">
import { useCountStore, useUserStore } from '@/stores'
import { storeToRefs } from 'pinia'

// 使用store
const countStore = useCountStore()
const userStore = useUserStore()

// 使用storeToRefs解构（保持响应式）
const { sum, bigSum, upperSchool } = storeToRefs(countStore)
const { userInfo } = storeToRefs(userStore)

// 直接使用actions
const { increment, decrement } = countStore
const { login, logout } = userStore

// 订阅store变化
countStore.$subscribe((mutate, state) => {
  console.log('countStore变化:', state)
  localStorage.setItem('count', JSON.stringify(state.sum))
})
</script>
```

## 4. 组件通信代码生成

### 4.1 Props通信模板
```vue
<!-- 父组件 -->
<template>
  <div class="father">
    <h3>父组件</h3>
    <h4>我的车：{{ car }}</h4>
    <h4>儿子给的玩具：{{ toy }}</h4>
    <Child :car="car" :getToy="getToy" />
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import Child from './Child.vue'

const car = ref('奔驰')
const toy = ref('')

const getToy = (value: string) => {
  toy.value = value
}
</script>

<!-- 子组件 -->
<template>
  <div class="child">
    <h3>子组件</h3>
    <h4>我的玩具：{{ toy }}</h4>
    <h4>父给我的车：{{ car }}</h4>
    <button @click="getToy(toy)">玩具给父亲</button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

interface Props {
  car: string
  getToy: (value: string) => void
}

const props = withDefaults(defineProps<Props>(), {
  car: '默认车'
})

const toy = ref('奥特曼')
</script>
```

### 4.2 自定义事件模板
```vue
<!-- 父组件 -->
<template>
  <div class="father">
    <h3>父组件</h3>
    <h4>收到的玩具：{{ toy }}</h4>
    <Child @send-toy="toy = $event" @send-car="car = $event" />
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import Child from './Child.vue'

const toy = ref('')
const car = ref('')
</script>

<!-- 子组件 -->
<template>
  <div class="child">
    <h3>子组件</h3>
    <button @click="sendToy">发送玩具</button>
    <button @click="sendCar">发送汽车</button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const emit = defineEmits<{
  'send-toy': [value: string]
  'send-car': [value: string]
}>()

const toy = ref('奥特曼')
const car = ref('宝马')

const sendToy = () => {
  emit('send-toy', toy.value)
}

const sendCar = () => {
  emit('send-car', car.value)
}
</script>
```

### 4.3 mitt事件总线模板
```typescript
// utils/emitter.ts
import mitt from 'mitt'

const emitter = mitt()

export default emitter
```

```vue
<!-- 发送方组件 -->
<template>
  <div class="sender">
    <button @click="sendMessage">发送消息</button>
  </div>
</template>

<script setup lang="ts">
import emitter from '@/utils/emitter'
import { ref } from 'vue'

const message = ref('Hello from sender')

const sendMessage = () => {
  emitter.emit('message', message.value)
}
</script>

<!-- 接收方组件 -->
<template>
  <div class="receiver">
    <h3>接收到的消息：{{ receivedMessage }}</h3>
  </div>
</template>

<script setup lang="ts">
import emitter from '@/utils/emitter'
import { ref, onMounted, onUnmounted } from 'vue'

const receivedMessage = ref('')

const handleMessage = (message: string) => {
  receivedMessage.value = message
}

onMounted(() => {
  emitter.on('message', handleMessage)
})

onUnmounted(() => {
  emitter.off('message', handleMessage)
})
</script>
```

### 4.4 v-model双向绑定模板
```vue
<!-- 父组件 -->
<template>
  <div class="parent">
    <h3>父组件</h3>
    <p>用户名：{{ userName }}</p>
    <p>密码：{{ password }}</p>
    
    <CustomInput v-model="userName" />
    <CustomInput v-model:password="password" />
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import CustomInput from './CustomInput.vue'

const userName = ref('')
const password = ref('')
</script>

<!-- 子组件 -->
<template>
  <div class="custom-input">
    <input 
      type="text" 
      :value="modelValue" 
      @input="emit('update:modelValue', ($event.target as HTMLInputElement).value)"
    />
    <input 
      type="password" 
      :value="password" 
      @input="emit('update:password', ($event.target as HTMLInputElement).value)"
    />
  </div>
</template>

<script setup lang="ts">
interface Props {
  modelValue: string
  password?: string
}

const props = withDefaults(defineProps<Props>(), {
  password: ''
})

const emit = defineEmits<{
  'update:modelValue': [value: string]
  'update:password': [value: string]
}>()
</script>
```

### 4.5 provide/inject模板
```vue
<!-- 祖先组件 -->
<template>
  <div class="ancestor">
    <h3>祖先组件</h3>
    <p>资产：{{ money }}</p>
    <p>汽车：{{ car.brand }} - {{ car.price }}万</p>
    <button @click="money += 1">资产+1</button>
    <button @click="car.price += 1">汽车价格+1</button>
    <Child />
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, provide } from 'vue'
import Child from './Child.vue'

const money = ref(100)
const car = reactive({
  brand: '奔驰',
  price: 100
})

const updateMoney = (value: number) => {
  money.value += value
}

// 提供数据
provide('moneyContext', { money, updateMoney })
provide('car', car)
</script>

<!-- 后代组件 -->
<template>
  <div class="descendant">
    <h3>后代组件</h3>
    <p>资产：{{ money }}</p>
    <p>汽车：{{ car.brand }} - {{ car.price }}万</p>
    <button @click="updateMoney(10)">增加资产</button>
  </div>
</template>

<script setup lang="ts">
import { inject } from 'vue'

// 注入数据
const { money, updateMoney } = inject('moneyContext', { 
  money: ref(0), 
  updateMoney: (x: number) => {} 
})
const car = inject('car')
</script>
```

## 5. 插槽代码生成

### 5.1 默认插槽模板
```vue
<!-- 父组件 -->
<template>
  <div class="parent">
    <Category title="今日热门游戏">
      <ul>
        <li v-for="game in games" :key="game.id">{{ game.name }}</li>
      </ul>
    </Category>
  </div>
</template>

<script setup lang="ts">
import { reactive } from 'vue'
import Category from './Category.vue'

const games = reactive([
  { id: '1', name: '英雄联盟' },
  { id: '2', name: '王者荣耀' }
])
</script>

<!-- 子组件 -->
<template>
  <div class="category">
    <h3>{{ title }}</h3>
    <!-- 默认插槽 -->
    <slot></slot>
  </div>
</template>

<script setup lang="ts">
interface Props {
  title: string
}

defineProps<Props>()
</script>
```

### 5.2 具名插槽模板
```vue
<!-- 父组件 -->
<template>
  <div class="parent">
    <Category title="今日热门游戏">
      <template #s1>
        <ul>
          <li v-for="game in games" :key="game.id">{{ game.name }}</li>
        </ul>
      </template>
      <template #s2>
        <a href="">更多</a>
      </template>
    </Category>
  </div>
</template>

<!-- 子组件 -->
<template>
  <div class="category">
    <h3>{{ title }}</h3>
    <slot name="s1"></slot>
    <slot name="s2"></slot>
  </div>
</template>
```

### 5.3 作用域插槽模板
```vue
<!-- 父组件 -->
<template>
  <div class="parent">
    <Game v-slot="params">
      <ul>
        <li v-for="game in params.games" :key="game.id">{{ game.name }}</li>
      </ul>
    </Game>
  </div>
</template>

<!-- 子组件 -->
<template>
  <div class="game">
    <h2>今日游戏榜单</h2>
    <slot :games="games" :total="total"></slot>
  </div>
</template>

<script setup lang="ts">
import { reactive, computed } from 'vue'

const games = reactive([
  { id: '1', name: '英雄联盟' },
  { id: '2', name: '王者荣耀' }
])

const total = computed(() => games.length)
</script>
```

## 6. 高级API代码生成

### 6.1 shallowRef/shallowReactive模板
```typescript
import { shallowRef, shallowReactive } from 'vue'

// shallowRef - 只对顶层属性响应式
const user = shallowRef({
  name: '张三',
  profile: {
    age: 18,
    address: {
      city: '北京'
    }
  }
})

// 只有整个对象替换才会触发更新
user.value = { name: '李四', profile: { age: 20, address: { city: '上海' } } }

// shallowReactive - 只对顶层属性响应式
const state = shallowReactive({
  count: 0,
  nested: {
    value: 1
  }
})

// 只有顶层属性变化才会触发更新
state.count = 1 // 会触发更新
state.nested.value = 2 // 不会触发更新
```

### 6.2 readonly/shallowReadonly模板
```typescript
import { reactive, readonly, shallowReadonly } from 'vue'

const original = reactive({
  name: '张三',
  profile: {
    age: 18
  }
})

// readonly - 深只读
const readOnlyCopy = readonly(original)
// readOnlyCopy.name = '李四' // 错误
// readOnlyCopy.profile.age = 20 // 错误

// shallowReadonly - 浅只读
const shallowReadOnlyCopy = shallowReadonly(original)
// shallowReadOnlyCopy.name = '李四' // 错误
shallowReadOnlyCopy.profile.age = 20 // 可以修改
```

### 6.3 toRaw/markRaw模板
```typescript
import { reactive, toRaw, markRaw, isReactive } from 'vue'

// toRaw - 获取原始对象
const reactiveObj = reactive({ name: '张三' })
const rawObj = toRaw(reactiveObj)
console.log(isReactive(reactiveObj)) // true
console.log(isReactive(rawObj)) // false

// markRaw - 标记永不响应式
const neverReactive = markRaw({ name: '李四' })
const attemptReactive = reactive(neverReactive)
console.log(isReactive(attemptReactive)) // false
```

### 6.4 customRef模板
```typescript
import { customRef } from 'vue'

// 防抖ref
function useDebouncedRef<T>(value: T, delay = 200) {
  let timeout: NodeJS.Timeout
  
  return customRef((track, trigger) => {
    return {
      get() {
        track()
        return value
      },
      set(newValue: T) {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          value = newValue
          trigger()
        }, delay)
      }
    }
  })
}

// 使用
const debouncedText = useDebouncedRef('')
```

## 7. 新组件代码生成

### 7.1 Teleport模板
```vue
<template>
  <div class="app">
    <button @click="showModal = true">显示弹窗</button>
    
    <!-- 将弹窗传送到body -->
    <Teleport to="body">
      <div v-if="showModal" class="modal">
        <div class="modal-content">
          <h2>弹窗标题</h2>
          <p>弹窗内容</p>
          <button @click="showModal = false">关闭</button>
        </div>
      </div>
    </Teleport>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const showModal = ref(false)
</script>

<style scoped>
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
}
</style>
```

### 7.2 Suspense模板
```vue
<template>
  <div class="app">
    <h3>我是App组件</h3>
    <Suspense>
      <template #default>
        <AsyncComponent />
      </template>
      <template #fallback>
        <div class="loading">
          <h3>加载中...</h3>
          <div class="spinner"></div>
        </div>
      </template>
    </Suspense>
  </div>
</template>

<script setup lang="ts">
import { defineAsyncComponent } from 'vue'

const AsyncComponent = defineAsyncComponent(() => 
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(import('./AsyncComponent.vue'))
    }, 2000)
  })
)
</script>
```

## 8. 生命周期代码生成

### 8.1 完整生命周期模板
```vue
<template>
  <div class="lifecycle-demo">
    <h2>当前求和为：{{ sum }}</h2>
    <button @click="sum += 1">+1</button>
  </div>
</template>

<script setup lang="ts">
import { 
  ref, 
  onBeforeMount, 
  onMounted, 
  onBeforeUpdate, 
  onUpdated, 
  onBeforeUnmount, 
  onUnmounted 
} from 'vue'

const sum = ref(0)

console.log('setup')

onBeforeMount(() => {
  console.log('挂载之前')
})

onMounted(() => {
  console.log('挂载完毕')
})

onBeforeUpdate(() => {
  console.log('更新之前')
})

onUpdated(() => {
  console.log('更新完毕')
})

onBeforeUnmount(() => {
  console.log('卸载之前')
})

onUnmounted(() => {
  console.log('卸载完毕')
})
</script>
```

## 9. 自定义Hook代码生成

### 9.1 自定义Hook模板
```typescript
// hooks/useCounter.ts
import { ref, computed } from 'vue'

export function useCounter(initialValue = 0) {
  const count = ref(initialValue)
  
  const doubleCount = computed(() => count.value * 2)
  
  const increment = () => {
    count.value++
  }
  
  const decrement = () => {
    count.value--
  }
  
  const reset = () => {
    count.value = initialValue
  }
  
  return {
    count,
    doubleCount,
    increment,
    decrement,
    reset
  }
}

// hooks/useApi.ts
import { ref } from 'vue'

export function useApi<T>(apiFunction: (...args: any[]) => Promise<T>) {
  const data = ref<T | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const execute = async (...args: any[]) => {
    try {
      loading.value = true
      error.value = null
      data.value = await apiFunction(...args)
    } catch (err) {
      error.value = err instanceof Error ? err.message : '请求失败'
    } finally {
      loading.value = false
    }
  }
  
  return {
    data,
    loading,
    error,
    execute
  }
}
```

### 9.2 Hook使用模板
```vue
<template>
  <div class="hook-demo">
    <h2>计数器：{{ count }}</h2>
    <h3>双倍值：{{ doubleCount }}</h3>
    <button @click="increment">+1</button>
    <button @click="decrement">-1</button>
    <button @click="reset">重置</button>
    
    <hr>
    
    <h2>API调用</h2>
    <button @click="fetchData" :disabled="loading">
      {{ loading ? '加载中...' : '获取数据' }}
    </button>
    <div v-if="error" class="error">{{ error }}</div>
    <div v-if="data" class="data">{{ data }}</div>
  </div>
</template>

<script setup lang="ts">
import { useCounter } from '@/hooks/useCounter'
import { useApi } from '@/hooks/useApi'

// 使用自定义Hook
const { count, doubleCount, increment, decrement, reset } = useCounter(10)

// 模拟API调用
const mockApi = () => new Promise(resolve => setTimeout(() => resolve('数据获取成功'), 1000))
const { data, loading, error, execute: fetchData } = useApi(mockApi)
</script>
```

- 使用v-memo优化列表渲染
- 合理使用computed和watch
- 避免在模板中使用复杂表达式
- 及时清理事件监听器和定时器



globs:

alwaysApply: true
---
