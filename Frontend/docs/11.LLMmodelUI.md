# LLM模块UI组织结构

## 概述

LLM模块是SuperMap前端应用中的AI助手功能模块，提供智能对话、历史记录管理等功能。该模块采用Vue 3 + TypeScript + Pinia技术栈，实现了清晰的组件层次结构和状态管理机制。

## 整体架构

### 1. 组件层次结构

```
Dashboard
└── ManagementAnalysis
    └── LLMMode (父容器)
        ├── ChatAssistant (聊天界面)
        └── ChatHistory (历史记录界面)
```

### 2. 路由配置

**路由层次：**
- `/dashboard/management-analysis/llm` → `LLMMode.vue` (父容器)
  - `/dashboard/management-analysis/llm/chat` → `ChatAssistant.vue` (默认子路由)
  - `/dashboard/management-analysis/llm/chat-history` → `ChatHistory.vue`

**路由配置代码：**
```typescript
// LLM模式
{
  path: 'llm',
  name: 'llm-mode',
  component: () => import('@/views/dashboard/management-analysis/LLM/LLMMode.vue'),
  meta: {
    title: 'AI助手',
    mode: 'llm',
    requiresAuth: true
  },
  children: [
    // LLM模式默认子路由
    {
      path: '',
      name: 'llm-mode-default',
      redirect: '/dashboard/management-analysis/llm/chat'
    },
    // 聊天界面
    {
      path: 'chat',
      name: 'llm-chat',
      component: () => import('@/views/dashboard/management-analysis/LLM/tools/ChatAssistant.vue'),
      meta: {
        title: 'AI聊天',
        requiresAuth: true
      }
    },
    // 历史聊天记录
    {
      path: 'chat-history',
      name: 'chat-history',
      component: () => import('@/views/dashboard/management-analysis/LLM/ChatHistory.vue'),
      meta: {
        title: '历史聊天记录',
        mode: 'llm',
        requiresAuth: true
      }
    }
  ]
}
```

## 核心组件详解

### 1. LLMMode.vue (父容器组件)

**职责：**
- 作为LLM模式的根容器，提供基础布局结构
- 管理LLM模式的生命周期和状态恢复
- 通过router-view动态渲染子路由组件
- 将地图状态传递给子组件

**核心功能：**
```typescript
// 组件生命周期管理
onMounted(() => {
  // 激活LLM模式，恢复状态
  modeStateStore.restoreModeState('llm')
})

// 通过router-view渲染子路由
<router-view :map-ready="mapStore.isMapReady" />
```

**布局结构：**
```vue
<template>
  <PanelContainer class="llm-panel">
    <div class="chat-container">
      <router-view :map-ready="mapStore.isMapReady" />
    </div>
  </PanelContainer>
</template>
```

### 2. ChatAssistant.vue (聊天助手组件)

**职责：**
- 核心聊天界面，处理用户交互和消息显示
- 管理聊天状态、消息历史、智能滚动
- 提供新对话和历史记录功能
- 实现消息渲染和状态持久化

**核心功能模块：**

#### 消息管理
```typescript
interface Message {
  id: number;
  text: string;
  sender: 'user' | 'system';
}

const messages = ref<Message[]>([]);
const newMessage = ref('');
```

#### 智能滚动机制
```typescript
// 检测滚动位置
const checkScrollPosition = () => {
  const el = messagesContainer.value;
  if (!el) return;
  
  const { scrollTop, scrollHeight, clientHeight } = el;
  const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
  isNearBottom.value = distanceFromBottom <= scrollThreshold;
};

// 判断是否应该自动滚动
const shouldAutoScroll = (): boolean => {
  return isNearBottom.value && !isUserScrolling.value;
};
```

#### 状态持久化
```typescript
// 保存LLM模式状态
const saveLLMState = () => {
  const scrollPosition = messagesContainer.value?.scrollTop || 0;
  modeStateStore.saveLLMState({
    messages: messages.value,
    inputText: newMessage.value,
    scrollPosition
  });
};
```

**UI结构：**
```vue
<template>
  <div class="chat-assistant">
    <!-- 功能按钮 -->
    <div class="fixed-buttons">
      <SecondaryButton @click="startNewConversation">新对话</SecondaryButton>
      <SecondaryButton @click="showChatHistory">历史记录</SecondaryButton>
    </div>
    
    <!-- 消息显示区域 -->
    <div class="messages-container" ref="messagesContainer">
      <div v-for="msg in messages" :key="msg.id" class="message-wrapper">
        <!-- 消息内容 -->
      </div>
    </div>
    
    <!-- 输入区域 -->
    <div class="input-container">
      <LLMInputGroup v-model="newMessage" @enter="sendMessage" />
      <button class="action-button" @click="sendMessage">发送</button>
    </div>
  </div>
</template>
```

### 3. ChatHistory.vue (历史记录组件)

**职责：**
- 管理聊天历史记录的显示和操作
- 提供历史记录的删除、切换、清空功能
- 处理历史记录与当前对话的切换

**核心功能：**

#### 历史记录管理
```typescript
// 加载聊天历史
const loadChatHistory = () => {
  isLoading.value = true;
  try {
    const savedChatHistory = localStorage.getItem('chatHistory') || '[]';
    chatHistory.value = JSON.parse(savedChatHistory);
  } catch (error) {
    console.error('加载聊天历史失败:', error);
    chatHistory.value = [];
  } finally {
    isLoading.value = false;
  }
};

// 切换历史对话
const toggleRecord = (recordId: string) => {
  const record = chatHistory.value.find(r => r.id === recordId);
  if (!record) return;

  // 将所选历史对话写入 LLM 模式状态
  const historyMessages = Array.isArray(record.messages) ? record.messages : [];
  modeStateStore.saveLLMState({
    messages: historyMessages,
    inputText: '',
    scrollPosition: 0
  });

  // 发送自定义事件通知ChatAssistant组件状态已更新
  window.dispatchEvent(new CustomEvent('chatHistoryRestored', {
    detail: {
      messages: historyMessages,
      recordId: recordId
    }
  }));
};
```

**UI结构：**
```vue
<template>
  <PanelWindow :visible="true" :embed="true">
    <div class="analysis-section">
      <!-- 操作按钮 -->
      <div class="action-buttons">
        <button @click="goBack">返回</button>
        <button @click="refreshHistory">刷新</button>
        <button @click="clearAllHistory">清空</button>
      </div>

      <!-- 聊天记录列表 -->
      <div class="chat-records-container">
        <div v-for="record in sortedHistory" :key="record.id" 
             class="chat-record-item" @click="selectRecord(record.id)">
          <!-- 记录信息 -->
        </div>
      </div>
    </div>
  </PanelWindow>
</template>
```

### 4. LLMInputGroup.vue (输入组件)

**职责：**
- 提供统一的输入组件，支持input和textarea两种模式
- 实现自动高度调整和滚动条样式
- 处理用户输入事件和键盘交互

**核心功能：**

#### 自动高度调整
```typescript
const adjustHeight = () => {
  nextTick(() => {
    if (textareaRef.value) {
      // 重置高度为auto，然后设置为scrollHeight
      textareaRef.value.style.height = 'auto';
      const scrollHeight = textareaRef.value.scrollHeight;
      textareaRef.value.style.height = Math.max(100, scrollHeight) + 'px';
    }
  });
};

// 监听modelValue变化，自动调整高度
watch(() => props.modelValue, adjustHeight, { immediate: true });
```

**组件接口：**
```typescript
interface Props {
  modelValue?: string;
  placeholder?: string;
  as?: 'input' | 'textarea';
  type?: string;
  rows?: number;
  disabled?: boolean;
}
```

## 状态管理机制

### 1. 模式状态管理

**使用useModeStateStore管理LLM模式状态：**
```typescript
// 保存状态
modeStateStore.saveLLMState({
  messages: messages.value,
  inputText: newMessage.value,
  scrollPosition: scrollPosition
});

// 恢复状态
const llmState = modeStateStore.getLLMState();
if (llmState.messages.length > 0) {
  messages.value = [...llmState.messages];
}
```

### 2. 数据持久化

**聊天历史存储：**
```typescript
// 保存到localStorage
const currentChat = {
  id: Date.now(),
  timestamp: new Date().toISOString(),
  messages: [...messages.value],
  messageCount: messages.value.length
};

chatHistory.push(currentChat);

// 限制历史记录数量，最多保存20条
if (chatHistory.length > 20) {
  chatHistory.splice(0, chatHistory.length - 20);
}

localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
```

### 3. 组件间通信

**自定义事件通信：**
```typescript
// 发送历史记录恢复事件
window.dispatchEvent(new CustomEvent('chatHistoryRestored', {
  detail: {
    messages: historyMessages,
    recordId: recordId
  }
}));

// 监听历史记录恢复事件
const handleChatHistoryRestored = (event: CustomEvent) => {
  const { messages: historyMessages } = event.detail;
  restoreHistoryMessages(historyMessages);
};

window.addEventListener('chatHistoryRestored', handleChatHistoryRestored);
```

## UI交互流程

### 1. 聊天流程

1. **进入LLM模式** → `LLMMode`激活并恢复状态
2. **默认显示聊天界面** → `ChatAssistant`组件渲染
3. **用户输入消息** → `LLMInputGroup`处理输入
4. **消息发送** → 添加到消息列表并智能滚动
5. **状态自动保存** → 保存到`modeStateStore`

### 2. 历史记录流程

1. **点击历史记录按钮** → 路由跳转到`ChatHistory`
2. **显示历史记录列表** → 支持删除、切换操作
3. **选择历史对话** → 恢复消息并跳转回聊天界面
4. **通过自定义事件通知** → `ChatAssistant`更新状态

### 3. 新对话流程

1. **点击新对话按钮** → 保存当前对话到历史记录
2. **清空消息历史** → 重置聊天状态
3. **显示初始消息** → 重新开始对话
4. **清空保存的状态** → 重置模式状态

## 样式和主题系统

### 1. 主题适配

**CSS变量系统：**
```css
/* 主要颜色变量 */
--accent: 主题色
--text: 文本颜色
--panel: 面板背景
--border: 边框颜色
--surface: 表面颜色
--sub: 次要文本颜色

/* 头像颜色 */
--avatar-ai-bg: AI头像背景
--avatar-user-bg: 用户头像背景

/* 固定按钮样式 */
--fixed-btn-bg: 固定按钮背景
--fixed-btn-border: 固定按钮边框
--fixed-btn-bg-hover: 固定按钮悬停背景
```

### 2. 响应式设计

**布局特点：**
- 使用Flexbox布局确保组件自适应
- 智能滚动机制，根据用户行为决定是否自动滚动
- 浮动按钮设计，不占用文档流空间
- 禁用动画防止主题切换闪烁

**滚动条样式：**
```css
/* 自定义滚动条 */
::-webkit-scrollbar {
  width: 3px;
}

::-webkit-scrollbar-track {
  background: var(--scrollbar-track, rgba(200, 200, 200, 0.1));
  border-radius: 1.5px;
}

::-webkit-scrollbar-thumb {
  background: var(--scrollbar-thumb, rgba(150, 150, 150, 0.3));
  border-radius: 1.5px;
}
```

## 技术特点

### 1. 性能优化

- **智能滚动**：根据用户滚动行为决定是否自动滚动到底部
- **状态持久化**：实时保存用户输入和滚动位置
- **组件懒加载**：使用动态导入减少初始加载时间
- **事件防抖**：滚动事件使用定时器防抖处理

### 2. 用户体验

- **流畅交互**：平滑滚动和动画效果
- **状态保持**：页面刷新后恢复聊天状态
- **历史管理**：支持多对话历史记录管理
- **主题适配**：支持明暗主题无缝切换

### 3. 代码质量

- **TypeScript支持**：完整的类型定义和类型检查
- **组件化设计**：清晰的职责分离和组件复用
- **状态管理**：统一的Pinia状态管理
- **错误处理**：完善的错误捕获和用户提示

## 扩展性

### 1. 功能扩展

- **消息类型扩展**：支持图片、文件、代码块等消息类型
- **AI功能集成**：集成更多AI分析功能
- **多语言支持**：国际化支持
- **插件系统**：支持第三方插件扩展

### 2. 性能扩展

- **虚拟滚动**：大量消息时的性能优化
- **消息分页**：历史消息分页加载
- **缓存机制**：智能缓存策略
- **离线支持**：离线消息同步

这种组织方式实现了清晰的职责分离、良好的状态管理和流畅的用户体验，同时保持了代码的可维护性和扩展性。
