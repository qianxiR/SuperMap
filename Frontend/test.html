<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>障碍分析测试页面</title>
    
    <!-- 引入Turf库 -->
    <script src="public/libs/turf/7.2.0/turf.min.js"></script>
    
    <style>
        .obstacle-analysis-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: Arial, sans-serif;
        }

        .analysis-controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input {
            margin-right: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .obstacle-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }

        .obstacle-item {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid #eee;
        }

        .obstacle-coords {
            margin: 10px 0;
        }

        .coord-input {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 5px;
        }

        .coord-input input {
            width: 60px;
            margin-right: 5px;
        }

        .remove-btn, .add-btn, .analyze-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }

        .remove-btn {
            background: #ff4757;
            color: white;
        }

        .add-btn {
            background: #2ed573;
            color: white;
        }

        .analyze-btn {
            background: #3742fa;
            color: white;
            font-size: 16px;
            padding: 12px 24px;
        }

        .results {
            background: #e8f5e8;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .result-info p {
            margin: 10px 0;
        }

        .path-coordinates {
            margin-top: 15px;
        }

        .path-coordinates pre {
            background: #f8f8f8;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }

        .error {
            background: #ffe6e6;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ff4757;
            display: none;
        }

        .error p {
            color: #ff4757;
            margin: 0;
        }

        .visualization-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .grid-controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .grid-controls label {
            font-weight: bold;
            margin-right: 10px;
        }

        .grid-controls input {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .update-grid-btn, .clear-grid-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .update-grid-btn {
            background: #007bff;
            color: white;
        }

        .clear-grid-btn {
            background: #6c757d;
            color: white;
        }

        #gridCanvas {
            border: 2px solid #ddd;
            border-radius: 4px;
            background: white;
            display: block;
            margin: 0 auto;
        }

        .grid-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #333;
        }

        .legend-color.start-point {
            background: #28a745;
        }

        .legend-color.end-point {
            background: #dc3545;
        }

        .legend-color.obstacle {
            background: #ffc107;
        }

        .legend-color.path {
            background: #007bff;
        }
    </style>
</head>
<body>
    <div class="obstacle-analysis-container">
        <h2>障碍分析测试页面</h2>
        
        <div class="analysis-controls">
            <div class="input-group">
                <label>起点坐标:</label>
                <input id="startX" type="number" placeholder="X坐标" value="-5" onchange="drawAll()" />
                <input id="startY" type="number" placeholder="Y坐标" value="-6" onchange="drawAll()" />
            </div>
            
            <div class="input-group">
                <label>终点坐标:</label>
                <input id="endX" type="number" placeholder="X坐标" value="9" onchange="drawAll()" />
                <input id="endY" type="number" placeholder="Y坐标" value="-6" onchange="drawAll()" />
            </div>
            
            <div class="obstacle-controls">
                <h3>障碍物设置</h3>
                <div id="obstacles-container">
                    <div class="obstacle-item" data-index="0">
                        <label>障碍物 1:</label>
                        <div class="obstacle-coords">
                            <div class="coord-input">
                                <input type="number" placeholder="X" value="0" onchange="drawAll()" />
                                <input type="number" placeholder="Y" value="-7" onchange="drawAll()" />
                            </div>
                            <div class="coord-input">
                                <input type="number" placeholder="X" value="5" onchange="drawAll()" />
                                <input type="number" placeholder="Y" value="-7" onchange="drawAll()" />
                            </div>
                            <div class="coord-input">
                                <input type="number" placeho  lder="X" value="5" onchange="drawAll()" />
                                <input type="number" placeholder="Y" value="-3" onchange="drawAll()" />
                            </div>
                            <div class="coord-input">
                                <input type="number" placeholder="X" value="0" onchange="drawAll()" />
                                <input type="number" placeholder="Y" value="-3" onchange="drawAll()" />
                            </div>
                            <div class="coord-input">
                                <input type="number" placeholder="X" value="0" onchange="drawAll()" />
                                <input type="number" placeholder="Y" value="-7" onchange="drawAll()" />
                            </div>
                        </div>
                        <button onclick="removeObstacle(0)" class="remove-btn">删除</button>
                    </div>
                </div>
                <button onclick="addObstacle()" class="add-btn">添加障碍物</button>
            </div>
            
            <button onclick="performAnalysis()" class="analyze-btn">执行障碍分析</button>
            <button onclick="testOfficialDemo()" class="analyze-btn" style="background: #ff6b35; margin-left: 10px;">测试官网Demo</button>
        </div>
        
        <div id="results" class="results">
            <h3>分析结果</h3>
            <div class="result-info">
                <p><strong>路径长度:</strong> <span id="pathDistance">0</span> 单位</p>
                <p><strong>路径坐标点数:</strong> <span id="pathPoints">0</span></p>
            </div>
            <div class="path-coordinates">
                <h4>路径坐标:</h4>
                <pre id="pathCoordinates"></pre>
            </div>
        </div>
        
        <div id="error" class="error">
            <h3>错误信息</h3>
            <p id="errorMessage"></p>
        </div>
        
        <!-- 可视化网格 -->
        <div class="visualization-container">
            <h3>可视化网格</h3>
            <div class="grid-controls">
                <label>网格范围:</label>
                <input id="gridMinX" type="number" value="-10" placeholder="最小X" />
                <input id="gridMaxX" type="number" value="15" placeholder="最大X" />
                <input id="gridMinY" type="number" value="-10" placeholder="最小Y" />
                <input id="gridMaxY" type="number" value="5" placeholder="最大Y" />
                <button onclick="updateGrid()" class="update-grid-btn">更新网格</button>
                <button onclick="clearGrid()" class="clear-grid-btn">清空网格</button>
            </div>
            <canvas id="gridCanvas" width="800" height="600"></canvas>
            <div class="grid-legend">
                <div class="legend-item">
                    <div class="legend-color start-point"></div>
                    <span>起点</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color end-point"></div>
                    <span>终点</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color obstacle"></div>
                    <span>障碍物</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color path"></div>
                    <span>路径</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        let obstacleIndex = 1;
        let currentPath = null;

        // 网格绘制相关变量
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        let gridBounds = {
            minX: -10,
            maxX: 15,
            minY: -10,
            maxY: 5
        };

        // 坐标转换函数
        function worldToCanvas(worldX, worldY) {
            const canvasX = ((worldX - gridBounds.minX) / (gridBounds.maxX - gridBounds.minX)) * canvas.width;
            const canvasY = canvas.height - ((worldY - gridBounds.minY) / (gridBounds.maxY - gridBounds.minY)) * canvas.height;
            return { x: canvasX, y: canvasY };
        }

        // 绘制网格
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景网格
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // 垂直网格线
            for (let x = gridBounds.minX; x <= gridBounds.maxX; x++) {
                const pos = worldToCanvas(x, 0);
                ctx.beginPath();
                ctx.moveTo(pos.x, 0);
                ctx.lineTo(pos.x, canvas.height);
                ctx.stroke();
            }
            
            // 水平网格线
            for (let y = gridBounds.minY; y <= gridBounds.maxY; y++) {
                const pos = worldToCanvas(0, y);
                ctx.beginPath();
                ctx.moveTo(0, pos.y);
                ctx.lineTo(canvas.width, pos.y);
                ctx.stroke();
            }
            
            // 绘制坐标轴
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // X轴
            const xAxisPos = worldToCanvas(0, 0);
            ctx.beginPath();
            ctx.moveTo(0, xAxisPos.y);
            ctx.lineTo(canvas.width, xAxisPos.y);
            ctx.stroke();
            
            // Y轴
            const yAxisPos = worldToCanvas(0, 0);
            ctx.beginPath();
            ctx.moveTo(yAxisPos.x, 0);
            ctx.lineTo(yAxisPos.x, canvas.height);
            ctx.stroke();
            
            // 绘制坐标标签
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X轴标签
            for (let x = gridBounds.minX; x <= gridBounds.maxX; x += 5) {
                const pos = worldToCanvas(x, 0);
                ctx.fillText(x.toString(), pos.x, xAxisPos.y + 15);
            }
            
            // Y轴标签
            ctx.textAlign = 'right';
            for (let y = gridBounds.minY; y <= gridBounds.maxY; y += 5) {
                const pos = worldToCanvas(0, y);
                ctx.fillText(y.toString(), yAxisPos.x - 5, pos.y + 4);
            }
        }

        // 绘制起点
        function drawStartPoint(x, y) {
            const pos = worldToCanvas(x, y);
            ctx.fillStyle = '#28a745';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 添加标签
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('起点', pos.x, pos.y - 15);
        }

        // 绘制终点
        function drawEndPoint(x, y) {
            const pos = worldToCanvas(x, y);
            ctx.fillStyle = '#dc3545';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 添加标签
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('终点', pos.x, pos.y - 15);
        }

        // 绘制障碍物
        function drawObstacles() {
            const obstacleCoordinates = getObstacleCoordinates();
            
            obstacleCoordinates.forEach((coords, index) => {
                ctx.fillStyle = 'rgba(255, 193, 7, 0.6)';
                ctx.strokeStyle = '#ffc107';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                const firstPos = worldToCanvas(coords[0][0], coords[0][1]);
                ctx.moveTo(firstPos.x, firstPos.y);
                
                for (let i = 1; i < coords.length; i++) {
                    const pos = worldToCanvas(coords[i][0], coords[i][1]);
                    ctx.lineTo(pos.x, pos.y);
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // 添加障碍物标签
                const centerX = coords.reduce((sum, coord) => sum + coord[0], 0) / coords.length;
                const centerY = coords.reduce((sum, coord) => sum + coord[1], 0) / coords.length;
                const centerPos = worldToCanvas(centerX, centerY);
                
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`障碍物${index + 1}`, centerPos.x, centerPos.y);
            });
        }

        // 绘制路径
        function drawPath(path) {
            if (!path || !path.geometry || !path.geometry.coordinates) return;
            
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            const firstPos = worldToCanvas(path.geometry.coordinates[0][0], path.geometry.coordinates[0][1]);
            ctx.moveTo(firstPos.x, firstPos.y);
            
            for (let i = 1; i < path.geometry.coordinates.length; i++) {
                const pos = worldToCanvas(path.geometry.coordinates[i][0], path.geometry.coordinates[i][1]);
                ctx.lineTo(pos.x, pos.y);
            }
            
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // 更新网格
        function updateGrid() {
            gridBounds.minX = parseFloat(document.getElementById('gridMinX').value) || -10;
            gridBounds.maxX = parseFloat(document.getElementById('gridMaxX').value) || 15;
            gridBounds.minY = parseFloat(document.getElementById('gridMinY').value) || -10;
            gridBounds.maxY = parseFloat(document.getElementById('gridMaxY').value) || 5;
            
            drawAll();
        }

        // 清空网格
        function clearGrid() {
            currentPath = null;
            drawAll();
        }

        // 绘制所有元素
        function drawAll() {
            drawGrid();
            
            // 绘制障碍物
            drawObstacles();
            
            // 绘制起点和终点
            const startX = parseFloat(document.getElementById('startX').value);
            const startY = parseFloat(document.getElementById('startY').value);
            const endX = parseFloat(document.getElementById('endX').value);
            const endY = parseFloat(document.getElementById('endY').value);
            
            if (!isNaN(startX) && !isNaN(startY)) {
                drawStartPoint(startX, startY);
            }
            
            if (!isNaN(endX) && !isNaN(endY)) {
                drawEndPoint(endX, endY);
            }
            
            // 绘制路径
            if (currentPath) {
                drawPath(currentPath);
            }
        }

        // 检查turf是否可用
        function checkTurfAvailability() {
            if (typeof window.turf === 'undefined') {
                showError('Turf库未加载，请检查turf库的引入路径');
                return false;
            }
            
            // 测试turf库基本功能
            try {
                const testPolygon = window.turf.polygon([[[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]]);
                console.log('Turf库测试成功:', testPolygon);
                return true;
            } catch (error) {
                showError(`Turf库测试失败: ${error.message}`);
                return false;
            }
        }

        // 显示错误信息
        function showError(message) {
            const errorDiv = document.getElementById('error');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            errorDiv.style.display = 'block';
            document.getElementById('results').style.display = 'none';
        }

        // 显示结果
        function showResults(result) {
            const resultsDiv = document.getElementById('results');
            const pathDistance = document.getElementById('pathDistance');
            const pathPoints = document.getElementById('pathPoints');
            const pathCoordinates = document.getElementById('pathCoordinates');
            
            // 计算路径长度（如果没有distance属性）
            let distance = 0;
            if (result.properties && result.properties.distance) {
                distance = result.properties.distance;
            } else if (result.geometry && result.geometry.coordinates) {
                // 手动计算路径长度
                const coords = result.geometry.coordinates;
                for (let i = 1; i < coords.length; i++) {
                    const prev = coords[i - 1];
                    const curr = coords[i];
                    const dx = curr[0] - prev[0];
                    const dy = curr[1] - prev[1];
                    distance += Math.sqrt(dx * dx + dy * dy);
                }
            }
            
            pathDistance.textContent = distance.toFixed(2);
            pathPoints.textContent = result.geometry.coordinates.length;
            pathCoordinates.textContent = JSON.stringify(result.geometry.coordinates, null, 2);
            
            resultsDiv.style.display = 'block';
            document.getElementById('error').style.display = 'none';
            
            // 更新可视化
            currentPath = result;
            drawAll();
        }

        // 添加障碍物
        function addObstacle() {
            const container = document.getElementById('obstacles-container');
            const obstacleDiv = document.createElement('div');
            obstacleDiv.className = 'obstacle-item';
            obstacleDiv.setAttribute('data-index', obstacleIndex);
            
            obstacleDiv.innerHTML = `
                <label>障碍物 ${obstacleIndex + 1}:</label>
                <div class="obstacle-coords">
                    <div class="coord-input">
                        <input type="number" placeholder="X" value="0" onchange="drawAll()" />
                        <input type="number" placeholder="Y" value="0" onchange="drawAll()" />
                    </div>
                    <div class="coord-input">
                        <input type="number" placeholder="X" value="1" onchange="drawAll()" />
                        <input type="number" placeholder="Y" value="0" onchange="drawAll()" />
                    </div>
                    <div class="coord-input">
                        <input type="number" placeholder="X" value="1" onchange="drawAll()" />
                        <input type="number" placeholder="Y" value="1" onchange="drawAll()" />
                    </div>
                    <div class="coord-input">
                        <input type="number" placeholder="X" value="0" onchange="drawAll()" />
                        <input type="number" placeholder="Y" value="1" onchange="drawAll()" />
                    </div>
                    <div class="coord-input">
                        <input type="number" placeholder="X" value="0" onchange="drawAll()" />
                        <input type="number" placeholder="Y" value="0" onchange="drawAll()" />
                    </div>
                </div>
                <button onclick="removeObstacle(${obstacleIndex})" class="remove-btn">删除</button>
            `;
            
            container.appendChild(obstacleDiv);
            obstacleIndex++;
            updateObstacleLabels();
        }

        // 删除障碍物
        function removeObstacle(index) {
            const obstacleDiv = document.querySelector(`[data-index="${index}"]`);
            if (obstacleDiv) {
                obstacleDiv.remove();
                updateObstacleLabels();
            }
        }

        // 更新障碍物标签
        function updateObstacleLabels() {
            const obstacles = document.querySelectorAll('.obstacle-item');
            obstacles.forEach((obstacle, index) => {
                const label = obstacle.querySelector('label');
                label.textContent = `障碍物 ${index + 1}:`;
            });
        }

        // 获取障碍物坐标
        function getObstacleCoordinates() {
            const obstacles = [];
            const obstacleItems = document.querySelectorAll('.obstacle-item');
            
            obstacleItems.forEach((item, itemIndex) => {
                const coordInputs = item.querySelectorAll('.coord-input');
                const coordinates = [];
                
                coordInputs.forEach((coordInput, coordIndex) => {
                    const inputs = coordInput.querySelectorAll('input');
                    if (inputs.length === 2) {
                        const x = parseFloat(inputs[0].value);
                        const y = parseFloat(inputs[1].value);
                        if (!isNaN(x) && !isNaN(y)) {
                            coordinates.push([x, y]);
                        }
                    }
                });
                
                console.log(`障碍物 ${itemIndex + 1} 坐标:`, coordinates);
                
                // 确保多边形是闭合的（第一个点和最后一个点相同）
                if (coordinates.length >= 3) {
                    // 检查是否闭合
                    const first = coordinates[0];
                    const last = coordinates[coordinates.length - 1];
                    if (first[0] !== last[0] || first[1] !== last[1]) {
                        coordinates.push([first[0], first[1]]);
                    }
                    obstacles.push(coordinates);
                }
            });
            
            console.log('所有障碍物坐标:', obstacles);
            return obstacles;
        }

        // 执行障碍分析
        function performAnalysis() {
            // 隐藏之前的结果和错误
            document.getElementById('results').style.display = 'none';
            document.getElementById('error').style.display = 'none';
            
            if (!checkTurfAvailability()) {
                return;
            }
            
            try {
                // 获取起点和终点坐标
                const startX = parseFloat(document.getElementById('startX').value);
                const startY = parseFloat(document.getElementById('startY').value);
                const endX = parseFloat(document.getElementById('endX').value);
                const endY = parseFloat(document.getElementById('endY').value);
                
                if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY)) {
                    showError('请输入有效的起点和终点坐标');
                    return;
                }
                
                const start = [startX, startY];
                const end = [endX, endY];
                
                // 获取障碍物坐标
                const obstacleCoordinates = getObstacleCoordinates();
                
                if (obstacleCoordinates.length === 0) {
                    showError('请至少添加一个障碍物');
                    return;
                }
                
                // 构建障碍物Feature对象
                const obstacleFeatures = obstacleCoordinates.map(coords => {
                    const polygon = window.turf.polygon([coords]);
                    console.log('构建的多边形:', polygon);
                    return polygon;
                });
                
                console.log('障碍物Feature对象:', obstacleFeatures);
                console.log('起点:', start);
                console.log('终点:', end);
                
                // 执行最短路径分析
                // 使用FeatureCollection格式
                const options = {
                    obstacles: window.turf.featureCollection(obstacleFeatures)
                };
                
                console.log('分析选项:', options);
                const path = window.turf.shortestPath(start, end, options);
                console.log('分析结果:', path);
                
                if (path && path.geometry && path.geometry.coordinates) {
                    showResults(path);
                } else {
                    showError('无法找到有效路径，请检查起点、终点和障碍物设置');
                }
            } catch (error) {
                showError(`分析过程中发生错误: ${error.message}`);
                console.error('障碍分析错误:', error);
            }
        }

        // 测试官网demo
        function testOfficialDemo() {
            if (!checkTurfAvailability()) {
                return;
            }
            
            try {
                console.log('开始测试官网demo...');
                
                var start = [-5, -6];
                var end = [9, -6];
                var obstaclePolygon = window.turf.polygon([
                    [
                        [0, -7],
                        [5, -7],
                        [5, -3],
                        [0, -3],
                        [0, -7],
                    ],
                ]);
                var options = {
                    obstacles: window.turf.featureCollection([obstaclePolygon])
                };
                
                console.log('官网demo参数:', { start, end, options });
                
                var path = window.turf.shortestPath(start, end, options);
                
                console.log('官网demo结果:', path);
                
                if (path && path.geometry && path.geometry.coordinates) {
                    showResults(path);
                } else {
                    showError('官网demo测试失败：无法找到有效路径');
                }
            } catch (error) {
                showError(`官网demo测试失败: ${error.message}`);
                console.error('官网demo错误:', error);
            }
        }

        // 页面加载完成后检查turf并初始化网格
        document.addEventListener('DOMContentLoaded', function() {
            checkTurfAvailability();
            // 初始化网格绘制
            setTimeout(() => {
                drawAll();
            }, 100);
        });
    </script>
</body>
</html>