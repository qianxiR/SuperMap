<template>
  <PanelWindow 
    :visible="analysisStore.toolPanel.visible && analysisStore.toolPanel.activeTool === 'intersect'"
    :embed="true"
    :width="'100%'"
    :height="'100%'"
    class="intersect-analysis-panel"
    title="相交分析"
  >
    <div class="analysis-section">
      <div class="group-title">选择第一个图层（目标面要素）</div>
      <DropdownSelect :options="layerOptionsWithNone" v-model="selectedTargetId" />

      <div class="group-title" style="margin-top:12px">选择第二个图层（计算要素）</div>
      <DropdownSelect :options="layerOptionsWithNone" v-model="selectedMaskId" />

      <div class="analysis-actions">
        <SecondaryButton text="开始执行相交" @click="handleExecute" />
        <SecondaryButton v-if="results.length > 0" text="清除相交结果" @click="handleClear" />
        <SecondaryButton text="保存为图层" @click="onSaveAsLayer" />
        <SecondaryButton text="导出为JSON" @click="onExportAsJSON" />
      </div>

      <!-- 运行时提示 -->
      <TipWindow 
        v-if="isAnalyzing"
        :visible="isAnalyzing"
        variant="info"
        :show-icon="true"
      >
        <div>
          <div style="font-weight: 600; margin-bottom: 4px;">正在执行相交分析...</div>
          <div style="font-size: 11px; opacity: 0.8;">
            正在对目标要素 ({{ targetFeatureCount }} 个) 和计算要素 ({{ maskFeatureCount }} 个) 进行分析
            <br> 
          </div>
        </div>
      </TipWindow>

      <!-- 错误提示 -->
      <TipWindow 
        v-if="errorMessage"
        :visible="!!errorMessage"
        variant="error"
        :show-icon="true"
      >
        <div>
          <div style="font-weight: 600; margin-bottom: 4px;">图层类型错误</div>
          <div style="font-size: 11px; opacity: 0.8;">
            {{ errorMessage }}
          </div>
        </div>
      </TipWindow>

      <div class="group-title" style="margin-top:16px">结果</div>
      
      <!-- 结果提示 -->
      <TipWindow 
        v-if="results.length > 0"
        :visible="results.length > 0"
        variant="success"
        :show-icon="true"
      >
        <div>
          <div style="font-weight: 600; margin-bottom: 4px;">相交分析完成</div>
          <div style="font-size: 11px; opacity: 0.8;">
            目标要素: {{ targetFeatureCount }} 个，计算要素: {{ maskFeatureCount }} 个，生成相交结果: {{ results.length }} 个
          </div>
        </div>
      </TipWindow>
    </div>
  </PanelWindow>
  
  <!-- 图层名称输入弹窗 -->
  <LayerNameModal
    :visible="showLayerNameModalRef"
    title="保存相交分析结果"
    placeholder="请输入图层名称"
    hint="图层名称用于在图层管理器中识别该相交分析结果"
    :default-name="defaultlayerName"
    @confirm="handlelayerNameConfirm"
    @close="handlelayerNameClose"
  />
  

</template>

<script setup lang="ts">
import { computed, ref, watch, onMounted, onUnmounted } from 'vue'
import { useIntersectionAnalysis } from '@/composables/useIntersectionAnalysis'
import { useMapStore } from '@/stores/mapStore'
import { useAnalysisStore } from '@/stores/analysisStore'
import DropdownSelect from '@/components/UI/DropdownSelect.vue'
import PanelWindow from '@/components/UI/PanelWindow.vue'
import TipWindow from '@/components/UI/TipWindow.vue'
import SecondaryButton from '@/components/UI/SecondaryButton.vue'
import LayerNameModal from '@/components/UI/LayerNameModal.vue'

const {
  targetlayerId,
  masklayerId,
  layerOptions,
  results,
  targetFeatureCount,
  maskFeatureCount,
  isAnalyzing,
  executeIntersectionAnalysis,
  clearState,
  setTargetlayer,
  setMasklayer,
  targetFeaturesCache,
  maskFeaturesCache,
  lastFeatureCollection,
  saveIntersectionResultsAsLayer,
  exportIntersectionResultsAsJSON
} = useIntersectionAnalysis()

const mapStore = useMapStore()
const analysisStore = useAnalysisStore()


// 错误消息状态
const errorMessage = ref<string>('')

const layerOptionsWithNone = computed(() => [{ value: '', label: '无', disabled: false }, ...layerOptions.value])

const selectedTargetId = computed({ get: () => targetlayerId.value, set: (v: string) => setTargetlayer(v) })
const selectedMaskId = computed({ get: () => masklayerId.value, set: (v: string) => setMasklayer(v) })

const handleExecute = async () => {
  // 清除之前的错误信息
  errorMessage.value = ''
  
  const tCount = targetFeaturesCache.value?.length || 0
  const mCount = maskFeaturesCache.value?.length || 0
  if (tCount < 1 || mCount < 1) {
    window.dispatchEvent(new CustomEvent('showNotification', {
      detail: {
        title: '提示',
        message: '请先选择两个包含要素的图层再执行相交分析。',
        type: 'warning',
        duration: 3000
      }
    }))
    return
  }

  const coordShape = (coords: any): number[] => {
    const sizes: number[] = []
    let cur: any = coords
    while (Array.isArray(cur)) {
      sizes.push(cur.length)
      cur = cur[0]
    }
    return sizes
  }
  const firstCoord = (coords: any): any => {
    let cur: any = coords
    while (Array.isArray(cur) && Array.isArray(cur[0])) cur = cur[0]
    return Array.isArray(cur) ? (cur as number[]).slice(0, 3) : cur
  }

  const tFirst = targetFeaturesCache.value?.[0]
  const mFirst = maskFeaturesCache.value?.[0]
  const tGeom = (tFirst as any)?.getGeometry?.()?.clone?.()
  const mGeom = (mFirst as any)?.getGeometry?.()?.clone?.()
  console.log('[Panel] execute clicked. source selection:', {
    targetlayerId: targetlayerId.value,
    masklayerId: masklayerId.value,
    targetCount: tCount,
    maskCount: mCount,
    targetFirstType: tGeom?.getType?.(),
    maskFirstType: mGeom?.getType?.()
  })

  try {
    // 执行相交分析
    await executeIntersectionAnalysis({
      targetlayerId: targetlayerId.value,
      masklayerId: masklayerId.value,
      targetFeatures: targetFeaturesCache.value,
      maskFeatures: maskFeaturesCache.value
    })
  } catch (error) {
    // 捕获错误并显示在 TipWindow 中
    errorMessage.value = error instanceof Error ? error.message : '执行相交分析时发生未知错误'
  }
}

const handleClear = () => {
  clearState()
}

// 保存/导出与命名弹窗
const showLayerNameModalRef = ref<boolean>(false)
const defaultlayerName = ref<string>('')
const generatelayerNameFromIntersect = () => '相交分析结果'
const showLayerNameModal = () => {
  if (!lastFeatureCollection.value || !lastFeatureCollection.value.features || lastFeatureCollection.value.features.length === 0) {
    return
  }
  defaultlayerName.value = generatelayerNameFromIntersect()
  showLayerNameModalRef.value = true
}
const handlelayerNameConfirm = async (layerName: string) => {
  showLayerNameModalRef.value = false
  await saveIntersectionResultsAsLayer(layerName)
}
const handlelayerNameClose = () => { showLayerNameModalRef.value = false }
const onSaveAsLayer = async () => { showLayerNameModal() }
const onExportAsJSON = async () => {
  await exportIntersectionResultsAsJSON(generatelayerNameFromIntersect())
}

// 清理相交分析状态（工具切换时调用）
const clearIntersectionAnalysisState = () => {
  clearState()
  analysisStore.setAnalysisStatus('相交分析状态已清理')
}

// 组件生命周期管理
onMounted(() => {
  analysisStore.setAnalysisStatus('请选择目标图层和计算图层')
})

onUnmounted(() => {
  clearIntersectionAnalysisState()
})

// 监听工具面板变化
watch(() => analysisStore.toolPanel?.activeTool, (tool, prevTool) => {
  if (tool === 'intersect' && prevTool !== 'intersect') {
    // 当进入相交分析时，只更新状态提示，不重复恢复状态
    if (results.value && results.value.length > 0) {
      analysisStore.setAnalysisStatus(`相交分析结果已加载（${results.value.length}个结果），点击"执行分析"重新显示`)
    } else {
      analysisStore.setAnalysisStatus('请选择目标图层和计算图层')
    }
  } else if (prevTool === 'intersect' && tool !== 'intersect') {
    // 当从相交分析切换到其他工具时，清理分析结果和地图显示
    clearIntersectionAnalysisState()
  }
}, { immediate: true })

// 监听面板关闭时，清除地图图层与状态
watch(() => analysisStore.toolPanel.visible.valueOf?.() ?? analysisStore.toolPanel.visible, (newVisible: any, oldVisible: any) => {
  try {
    const wasVisible = Boolean(oldVisible)
    const nowVisible = Boolean(newVisible)
    if (wasVisible && !nowVisible && (analysisStore.toolPanel.activeTool.valueOf?.() === 'intersect' || analysisStore.toolPanel.activeTool === 'intersect')) {
      clearIntersectionAnalysisState()
      analysisStore.setAnalysisStatus('相交分析面板已关闭，已清除图层与状态')
    }
  } catch (_) {
    clearIntersectionAnalysisState()
  }
})

</script>

<style scoped>
.analysis-section {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  box-shadow: var(--glow);
}
.btn {
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
}
.analysis-actions {
  margin-top: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.analysis-actions :deep(.btn) {
  width: 100%;
  justify-content: center;
}
</style>


