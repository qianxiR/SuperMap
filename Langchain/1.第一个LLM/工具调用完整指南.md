# LangChain 工具调用完整指南

## 目录
1. [工具调用概述](#工具调用概述)
2. [工具定义方式](#工具定义方式)
3. [工具绑定方法](#工具绑定方法)
4. [实际应用示例](#实际应用示例)
5. [最佳实践](#最佳实践)
6. [常见问题](#常见问题)

## 工具调用概述

工具调用（Tool Calling）是让AI模型能够调用外部函数或工具的能力。当模型遇到需要计算、查询数据或执行特定操作时，它可以自动调用相应的工具。

### 核心概念
- **工具（Tool）**：可被AI调用的函数或服务
- **工具绑定（Tool Binding）**：将工具与语言模型关联
- **工具调用（Tool Calling）**：AI自动识别并调用合适的工具
- **工具执行（Tool Execution）**：实际执行工具并返回结果

## 工具定义方式

### 方式一：使用 @tool 装饰器（推荐）

```python
from langchain_core.tools import tool

@tool
def multiply(first_int: int, second_int: int) -> int:
    """
    将两个整数相乘的工具函数
    
    Args:
        first_int: 第一个整数
        second_int: 第二个整数
    
    Returns:
        int: 两个整数的乘积
    """
    return first_int * second_int

@tool
def get_weather(location: str) -> str:
    """
    获取指定城市的天气信息
    
    Args:
        location: 城市名称
    
    Returns:
        str: 天气信息
    """
    # 模拟天气查询
    return f"{location}的天气：晴天，温度25°C"
```

**优点：**
- ✅ 简单易用，直接定义Python函数
- ✅ 类型安全，自动类型检查
- ✅ 自动生成工具描述和参数
- ✅ 函数可以直接调用和测试

### 方式二：使用字典格式（OpenAI Function Calling 格式）

```python
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_current_time",
            "description": "当你想知道现在的时间时非常有用。",
            "parameters": {},  # 无参数
        },
    },
    {
        "type": "function",
        "function": {
            "name": "get_current_weather",
            "description": "当你想查询指定城市的天气时非常有用。",
            "parameters": {
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "城市或县区，比如北京市、杭州市、余杭区等。",
                    }
                },
                "required": ["location"],
            },
        },
    },
]
```

**优点：**
- ✅ 标准化，符合OpenAI Function Calling规范
- ✅ 灵活性，可以定义虚拟工具
- ✅ 兼容性，与更多模型兼容
- ✅ 复杂参数结构支持

## 工具绑定方法

### 1. bind_tools() 方法（推荐）

```python
from langchain_community.chat_models.tongyi import ChatTongyi

# 创建模型实例
llm = ChatTongyi(model="qwen-turbo")

# 绑定工具
llm_with_tools = llm.bind_tools([multiply, get_weather])

# 使用
response = llm_with_tools.invoke("What's 5 times 42?")
```

### 2. bind() 方法

```python
# 使用字典格式工具
llm_kwargs = {
    "tools": tools,
    "result_format": "message"
}
llm_with_tools = llm.bind(**llm_kwargs)

# 使用
response = llm_with_tools.invoke("What's the weather in Beijing?")
```

### 3. with_structured_output() 方法

```python
from pydantic import BaseModel, Field

class WeatherInfo(BaseModel):
    """天气信息"""
    location: str = Field(description="城市名称")
    temperature: float = Field(description="温度")
    condition: str = Field(description="天气状况")

# 绑定结构化输出
structured_llm = llm.with_structured_output(WeatherInfo)

# 使用
weather_data = structured_llm.invoke("Tell me about the weather in Shanghai")
```

### 4. 直接传递工具参数

```python
# 在调用时直接传递工具
response = llm.invoke(
    "What's the weather like?",
    tools=[get_weather],
    result_format="message"
)
```

### 5. 批量绑定多个工具

```python
from langchain_core.tools import tool

@tool
def add(a: int, b: int) -> int:
    """加法运算"""
    return a + b

@tool
def subtract(a: int, b: int) -> int:
    """减法运算"""
    return a - b

@tool
def divide(a: int, b: int) -> float:
    """除法运算"""
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

# 批量绑定数学工具
math_tools = [add, subtract, multiply, divide]
llm_with_math = llm.bind_tools(math_tools)
```

## 实际应用示例

### 示例1：数学计算工具

```python
from langchain_community.chat_models.tongyi import ChatTongyi
from langchain_core.tools import tool
from langchain_core.messages import ToolMessage

# 定义数学工具
@tool
def calculate(expression: str) -> str:
    """
    计算数学表达式
    
    Args:
        expression: 数学表达式，如 "2 + 3 * 4"
    
    Returns:
        str: 计算结果
    """
    try:
        result = eval(expression)
        return f"计算结果：{expression} = {result}"
    except Exception as e:
        return f"计算错误：{str(e)}"

# 创建模型并绑定工具
llm = ChatTongyi(model="qwen-turbo")
llm_with_tools = llm.bind_tools([calculate])

# 使用工具
response = llm_with_tools.invoke("请计算 15 * 8 + 25")

# 检查是否有工具调用
if response.tool_calls:
    tool_call = response.tool_calls[0]
    print(f"工具名称: {tool_call['name']}")
    print(f"调用参数: {tool_call['args']}")
    
    # 执行工具
    result = calculate.invoke(tool_call['args'])
    print(f"执行结果: {result}")
    
    # 创建工具消息并获取最终回答
    tool_message = ToolMessage(
        content=result,
        tool_call_id=tool_call['id']
    )
    
    final_response = llm_with_tools.invoke([
        {"role": "user", "content": "请计算 15 * 8 + 25"},
        response,
        tool_message
    ])
    
    print(f"最终回答: {final_response.content}")
```

### 示例2：天气查询工具

```python
import requests
from langchain_core.tools import tool

@tool
def get_weather_info(city: str) -> str:
    """
    获取城市天气信息
    
    Args:
        city: 城市名称
    
    Returns:
        str: 天气信息
    """
    # 模拟天气API调用
    weather_data = {
        "北京": "晴天，温度22°C，湿度45%",
        "上海": "多云，温度25°C，湿度60%",
        "广州": "小雨，温度28°C，湿度80%",
        "深圳": "阴天，温度26°C，湿度70%"
    }
    
    return weather_data.get(city, f"抱歉，暂时无法获取{city}的天气信息")

# 使用天气工具
llm_with_weather = llm.bind_tools([get_weather_info])
response = llm_with_weather.invoke("北京今天天气怎么样？")
```

### 示例3：文件操作工具

```python
import os
from langchain_core.tools import tool

@tool
def read_file(file_path: str) -> str:
    """
    读取文件内容
    
    Args:
        file_path: 文件路径
    
    Returns:
        str: 文件内容
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"读取文件失败：{str(e)}"

@tool
def write_file(file_path: str, content: str) -> str:
    """
    写入文件内容
    
    Args:
        file_path: 文件路径
        content: 要写入的内容
    
    Returns:
        str: 操作结果
    """
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        return f"成功写入文件：{file_path}"
    except Exception as e:
        return f"写入文件失败：{str(e)}"

# 绑定文件操作工具
file_tools = [read_file, write_file]
llm_with_file_tools = llm.bind_tools(file_tools)
```

## 最佳实践

### 1. 工具设计原则

```python
# ✅ 好的工具设计
@tool
def calculate_tax(income: float, tax_rate: float = 0.1) -> dict:
    """
    计算个人所得税
    
    Args:
        income: 收入金额
        tax_rate: 税率，默认10%
    
    Returns:
        dict: 包含税额和税后收入的字典
    """
    tax_amount = income * tax_rate
    after_tax_income = income - tax_amount
    
    return {
        "tax_amount": tax_amount,
        "after_tax_income": after_tax_income,
        "tax_rate": tax_rate
    }

# ❌ 避免的设计
@tool
def bad_tool(x, y, z, a, b, c):  # 参数过多，没有类型提示
    """不好的工具设计"""
    return x + y + z + a + b + c
```

### 2. 错误处理

```python
@tool
def safe_divide(a: float, b: float) -> str:
    """
    安全除法运算
    
    Args:
        a: 被除数
        b: 除数
    
    Returns:
        str: 计算结果或错误信息
    """
    try:
        if b == 0:
            return "错误：除数不能为零"
        result = a / b
        return f"{a} ÷ {b} = {result}"
    except Exception as e:
        return f"计算错误：{str(e)}"
```

### 3. 工具组合使用

```python
# 定义多个相关工具
@tool
def get_user_info(user_id: str) -> dict:
    """获取用户信息"""
    return {"user_id": user_id, "name": "张三", "email": "zhangsan@example.com"}

@tool
def send_email(to: str, subject: str, content: str) -> str:
    """发送邮件"""
    return f"邮件已发送给 {to}，主题：{subject}"

@tool
def create_task(title: str, description: str, assignee: str) -> str:
    """创建任务"""
    return f"任务已创建：{title}，分配给 {assignee}"

# 组合使用
workflow_tools = [get_user_info, send_email, create_task]
llm_with_workflow = llm.bind_tools(workflow_tools)
```

### 4. 工具链式调用

```python
from langchain_core.runnables import RunnableLambda

def process_tool_result(result):
    """处理工具结果"""
    if isinstance(result, str) and "错误" in result:
        return f"工具执行失败：{result}"
    return f"工具执行成功：{result}"

# 创建工具链
tool_chain = (
    llm.bind_tools([calculate])
    | RunnableLambda(lambda x: x.tool_calls[0] if x.tool_calls else None)
    | RunnableLambda(lambda x: calculate.invoke(x['args']) if x else "无工具调用")
    | RunnableLambda(process_tool_result)
)
```

## 常见问题

### Q1: 工具调用失败怎么办？

```python
# 检查工具调用状态
if response.tool_calls:
    for tool_call in response.tool_calls:
        try:
            # 执行工具
            result = tool.invoke(tool_call['args'])
        except Exception as e:
            # 处理错误
            result = f"工具执行失败：{str(e)}"
        
        # 创建工具消息
        tool_message = ToolMessage(
            content=result,
            tool_call_id=tool_call['id']
        )
```

### Q2: 如何调试工具调用？

```python
# 添加调试信息
@tool
def debug_tool(input_data: str) -> str:
    """调试工具"""
    print(f"工具输入：{input_data}")
    result = f"处理结果：{input_data.upper()}"
    print(f"工具输出：{result}")
    return result

# 检查工具调用详情
print(f"工具调用数量：{len(response.tool_calls)}")
for i, tool_call in enumerate(response.tool_calls):
    print(f"工具 {i+1}: {tool_call['name']}")
    print(f"参数：{tool_call['args']}")
    print(f"ID：{tool_call['id']}")
```

### Q3: 如何优化工具性能？

```python
import time
from functools import lru_cache

@lru_cache(maxsize=100)
@tool
def cached_weather(city: str) -> str:
    """带缓存的天气查询"""
    # 模拟API调用延迟
    time.sleep(0.1)
    return f"{city}的天气：晴天，25°C"

# 使用缓存提高性能
llm_with_cached_tools = llm.bind_tools([cached_weather])
```

### Q4: 如何处理复杂参数？

```python
from pydantic import BaseModel, Field
from typing import List, Optional

class SearchParams(BaseModel):
    """搜索参数"""
    query: str = Field(description="搜索关键词")
    limit: int = Field(default=10, description="结果数量限制")
    filters: Optional[List[str]] = Field(default=None, description="过滤条件")

@tool
def advanced_search(params: SearchParams) -> str:
    """
    高级搜索功能
    
    Args:
        params: 搜索参数对象
    
    Returns:
        str: 搜索结果
    """
    return f"搜索 '{params.query}'，限制 {params.limit} 条结果"
```

## 总结

工具调用是LangChain中非常强大的功能，它让AI模型能够：

1. **自动识别**需要调用工具的场景
2. **智能选择**合适的工具
3. **正确解析**用户输入为工具参数
4. **执行工具**并获取结果
5. **整合结果**为用户提供完整回答

通过合理设计和使用工具，可以大大扩展AI模型的能力，实现更复杂的应用场景。

---

*本文档基于LangChain最新版本编写，如有更新请参考官方文档。*
